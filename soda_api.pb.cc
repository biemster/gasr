// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: soda_api.proto

#include "soda_api.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace speech {
namespace soda {
namespace chrome {
PROTOBUF_CONSTEXPR ExtendedSodaConfigMsg::ExtendedSodaConfigMsg(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.config_file_location_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.api_key_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.language_pack_directory_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.multilang_config_)*/nullptr
  , /*decltype(_impl_.channel_count_)*/0
  , /*decltype(_impl_.sample_rate_)*/0
  , /*decltype(_impl_.max_buffer_bytes_)*/0
  , /*decltype(_impl_.simulate_realtime_testonly_)*/false
  , /*decltype(_impl_.enable_lang_id_)*/false
  , /*decltype(_impl_.enable_speaker_change_detection_)*/false
  , /*decltype(_impl_.include_logging_)*/false
  , /*decltype(_impl_.recognition_mode_)*/1
  , /*decltype(_impl_.reset_on_final_result_)*/true
  , /*decltype(_impl_.include_timing_metrics_)*/true
  , /*decltype(_impl_.enable_formatting_)*/true} {}
struct ExtendedSodaConfigMsgDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ExtendedSodaConfigMsgDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ExtendedSodaConfigMsgDefaultTypeInternal() {}
  union {
    ExtendedSodaConfigMsg _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ExtendedSodaConfigMsgDefaultTypeInternal _ExtendedSodaConfigMsg_default_instance_;
PROTOBUF_CONSTEXPR MultilangConfig_MultilangLanguagePackDirectoryEntry_DoNotUse::MultilangConfig_MultilangLanguagePackDirectoryEntry_DoNotUse(
    ::_pbi::ConstantInitialized) {}
struct MultilangConfig_MultilangLanguagePackDirectoryEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MultilangConfig_MultilangLanguagePackDirectoryEntry_DoNotUseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MultilangConfig_MultilangLanguagePackDirectoryEntry_DoNotUseDefaultTypeInternal() {}
  union {
    MultilangConfig_MultilangLanguagePackDirectoryEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MultilangConfig_MultilangLanguagePackDirectoryEntry_DoNotUseDefaultTypeInternal _MultilangConfig_MultilangLanguagePackDirectoryEntry_DoNotUse_default_instance_;
PROTOBUF_CONSTEXPR MultilangConfig::MultilangConfig(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.multilang_language_pack_directory_)*/{}
  , /*decltype(_impl_.rewind_when_switching_language_)*/false} {}
struct MultilangConfigDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MultilangConfigDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MultilangConfigDefaultTypeInternal() {}
  union {
    MultilangConfig _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MultilangConfigDefaultTypeInternal _MultilangConfig_default_instance_;
PROTOBUF_CONSTEXPR TimingMetrics::TimingMetrics(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.audio_start_epoch_usec_)*/int64_t{0}
  , /*decltype(_impl_.audio_start_time_usec_)*/int64_t{0}
  , /*decltype(_impl_.elapsed_wall_time_usec_)*/int64_t{0}
  , /*decltype(_impl_.event_end_time_usec_)*/int64_t{0}} {}
struct TimingMetricsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TimingMetricsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TimingMetricsDefaultTypeInternal() {}
  union {
    TimingMetrics _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TimingMetricsDefaultTypeInternal _TimingMetrics_default_instance_;
PROTOBUF_CONSTEXPR HypothesisPart::HypothesisPart(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.text_)*/{}
  , /*decltype(_impl_.alignment_ms_)*/int64_t{0}} {}
struct HypothesisPartDefaultTypeInternal {
  PROTOBUF_CONSTEXPR HypothesisPartDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~HypothesisPartDefaultTypeInternal() {}
  union {
    HypothesisPart _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 HypothesisPartDefaultTypeInternal _HypothesisPart_default_instance_;
PROTOBUF_CONSTEXPR SodaRecognitionResult::SodaRecognitionResult(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.hypothesis_)*/{}
  , /*decltype(_impl_.hypothesis_part_)*/{}
  , /*decltype(_impl_.timing_metrics_)*/nullptr
  , /*decltype(_impl_.result_type_)*/0
  , /*decltype(_impl_.endpoint_reason_)*/0} {}
struct SodaRecognitionResultDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SodaRecognitionResultDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SodaRecognitionResultDefaultTypeInternal() {}
  union {
    SodaRecognitionResult _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SodaRecognitionResultDefaultTypeInternal _SodaRecognitionResult_default_instance_;
PROTOBUF_CONSTEXPR SodaEndpointEvent::SodaEndpointEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.timing_metrics_)*/nullptr
  , /*decltype(_impl_.endpoint_type_)*/4} {}
struct SodaEndpointEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SodaEndpointEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SodaEndpointEventDefaultTypeInternal() {}
  union {
    SodaEndpointEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SodaEndpointEventDefaultTypeInternal _SodaEndpointEvent_default_instance_;
PROTOBUF_CONSTEXPR SodaAudioLevelInfo::SodaAudioLevelInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.rms_)*/0
  , /*decltype(_impl_.audio_level_)*/0
  , /*decltype(_impl_.audio_time_usec_)*/int64_t{0}} {}
struct SodaAudioLevelInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SodaAudioLevelInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SodaAudioLevelInfoDefaultTypeInternal() {}
  union {
    SodaAudioLevelInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SodaAudioLevelInfoDefaultTypeInternal _SodaAudioLevelInfo_default_instance_;
PROTOBUF_CONSTEXPR SodaLangIdEvent::SodaLangIdEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.language_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.confidence_level_)*/0} {}
struct SodaLangIdEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SodaLangIdEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SodaLangIdEventDefaultTypeInternal() {}
  union {
    SodaLangIdEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SodaLangIdEventDefaultTypeInternal _SodaLangIdEvent_default_instance_;
PROTOBUF_CONSTEXPR SodaResponse::SodaResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.log_lines_)*/{}
  , /*decltype(_impl_.recognition_result_)*/nullptr
  , /*decltype(_impl_.endpoint_event_)*/nullptr
  , /*decltype(_impl_.audio_level_info_)*/nullptr
  , /*decltype(_impl_.langid_event_)*/nullptr
  , /*decltype(_impl_.soda_type_)*/0} {}
struct SodaResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SodaResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SodaResponseDefaultTypeInternal() {}
  union {
    SodaResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SodaResponseDefaultTypeInternal _SodaResponse_default_instance_;
}  // namespace chrome
}  // namespace soda
}  // namespace speech
namespace speech {
namespace soda {
namespace chrome {
bool ExtendedSodaConfigMsg_RecognitionMode_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ExtendedSodaConfigMsg_RecognitionMode_strings[3] = {};

static const char ExtendedSodaConfigMsg_RecognitionMode_names[] =
  "CAPTION"
  "IME"
  "UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ExtendedSodaConfigMsg_RecognitionMode_entries[] = {
  { {ExtendedSodaConfigMsg_RecognitionMode_names + 0, 7}, 2 },
  { {ExtendedSodaConfigMsg_RecognitionMode_names + 7, 3}, 1 },
  { {ExtendedSodaConfigMsg_RecognitionMode_names + 10, 7}, 0 },
};

static const int ExtendedSodaConfigMsg_RecognitionMode_entries_by_number[] = {
  2, // 0 -> UNKNOWN
  1, // 1 -> IME
  0, // 2 -> CAPTION
};

const std::string& ExtendedSodaConfigMsg_RecognitionMode_Name(
    ExtendedSodaConfigMsg_RecognitionMode value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ExtendedSodaConfigMsg_RecognitionMode_entries,
          ExtendedSodaConfigMsg_RecognitionMode_entries_by_number,
          3, ExtendedSodaConfigMsg_RecognitionMode_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ExtendedSodaConfigMsg_RecognitionMode_entries,
      ExtendedSodaConfigMsg_RecognitionMode_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ExtendedSodaConfigMsg_RecognitionMode_strings[idx].get();
}
bool ExtendedSodaConfigMsg_RecognitionMode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ExtendedSodaConfigMsg_RecognitionMode* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ExtendedSodaConfigMsg_RecognitionMode_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<ExtendedSodaConfigMsg_RecognitionMode>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ExtendedSodaConfigMsg_RecognitionMode ExtendedSodaConfigMsg::UNKNOWN;
constexpr ExtendedSodaConfigMsg_RecognitionMode ExtendedSodaConfigMsg::IME;
constexpr ExtendedSodaConfigMsg_RecognitionMode ExtendedSodaConfigMsg::CAPTION;
constexpr ExtendedSodaConfigMsg_RecognitionMode ExtendedSodaConfigMsg::RecognitionMode_MIN;
constexpr ExtendedSodaConfigMsg_RecognitionMode ExtendedSodaConfigMsg::RecognitionMode_MAX;
constexpr int ExtendedSodaConfigMsg::RecognitionMode_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool SodaRecognitionResult_ResultType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> SodaRecognitionResult_ResultType_strings[4] = {};

static const char SodaRecognitionResult_ResultType_names[] =
  "FINAL"
  "PARTIAL"
  "PREFETCH"
  "UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry SodaRecognitionResult_ResultType_entries[] = {
  { {SodaRecognitionResult_ResultType_names + 0, 5}, 2 },
  { {SodaRecognitionResult_ResultType_names + 5, 7}, 1 },
  { {SodaRecognitionResult_ResultType_names + 12, 8}, 3 },
  { {SodaRecognitionResult_ResultType_names + 20, 7}, 0 },
};

static const int SodaRecognitionResult_ResultType_entries_by_number[] = {
  3, // 0 -> UNKNOWN
  1, // 1 -> PARTIAL
  0, // 2 -> FINAL
  2, // 3 -> PREFETCH
};

const std::string& SodaRecognitionResult_ResultType_Name(
    SodaRecognitionResult_ResultType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          SodaRecognitionResult_ResultType_entries,
          SodaRecognitionResult_ResultType_entries_by_number,
          4, SodaRecognitionResult_ResultType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      SodaRecognitionResult_ResultType_entries,
      SodaRecognitionResult_ResultType_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     SodaRecognitionResult_ResultType_strings[idx].get();
}
bool SodaRecognitionResult_ResultType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SodaRecognitionResult_ResultType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      SodaRecognitionResult_ResultType_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<SodaRecognitionResult_ResultType>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr SodaRecognitionResult_ResultType SodaRecognitionResult::UNKNOWN;
constexpr SodaRecognitionResult_ResultType SodaRecognitionResult::PARTIAL;
constexpr SodaRecognitionResult_ResultType SodaRecognitionResult::FINAL;
constexpr SodaRecognitionResult_ResultType SodaRecognitionResult::PREFETCH;
constexpr SodaRecognitionResult_ResultType SodaRecognitionResult::ResultType_MIN;
constexpr SodaRecognitionResult_ResultType SodaRecognitionResult::ResultType_MAX;
constexpr int SodaRecognitionResult::ResultType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool SodaRecognitionResult_FinalResultEndpointReason_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> SodaRecognitionResult_FinalResultEndpointReason_strings[7] = {};

static const char SodaRecognitionResult_FinalResultEndpointReason_names[] =
  "ENDPOINT_ASR_ERROR"
  "ENDPOINT_ASR_RESET_BY_HOTWORD"
  "ENDPOINT_ASR_RESET_EXTERNAL"
  "ENDPOINT_END_OF_AUDIO"
  "ENDPOINT_END_OF_SPEECH"
  "ENDPOINT_END_OF_UTTERANCE"
  "ENDPOINT_UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry SodaRecognitionResult_FinalResultEndpointReason_entries[] = {
  { {SodaRecognitionResult_FinalResultEndpointReason_names + 0, 18}, 6 },
  { {SodaRecognitionResult_FinalResultEndpointReason_names + 18, 29}, 4 },
  { {SodaRecognitionResult_FinalResultEndpointReason_names + 47, 27}, 5 },
  { {SodaRecognitionResult_FinalResultEndpointReason_names + 74, 21}, 3 },
  { {SodaRecognitionResult_FinalResultEndpointReason_names + 95, 22}, 1 },
  { {SodaRecognitionResult_FinalResultEndpointReason_names + 117, 25}, 2 },
  { {SodaRecognitionResult_FinalResultEndpointReason_names + 142, 16}, 0 },
};

static const int SodaRecognitionResult_FinalResultEndpointReason_entries_by_number[] = {
  6, // 0 -> ENDPOINT_UNKNOWN
  4, // 1 -> ENDPOINT_END_OF_SPEECH
  5, // 2 -> ENDPOINT_END_OF_UTTERANCE
  3, // 3 -> ENDPOINT_END_OF_AUDIO
  1, // 4 -> ENDPOINT_ASR_RESET_BY_HOTWORD
  2, // 5 -> ENDPOINT_ASR_RESET_EXTERNAL
  0, // 6 -> ENDPOINT_ASR_ERROR
};

const std::string& SodaRecognitionResult_FinalResultEndpointReason_Name(
    SodaRecognitionResult_FinalResultEndpointReason value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          SodaRecognitionResult_FinalResultEndpointReason_entries,
          SodaRecognitionResult_FinalResultEndpointReason_entries_by_number,
          7, SodaRecognitionResult_FinalResultEndpointReason_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      SodaRecognitionResult_FinalResultEndpointReason_entries,
      SodaRecognitionResult_FinalResultEndpointReason_entries_by_number,
      7, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     SodaRecognitionResult_FinalResultEndpointReason_strings[idx].get();
}
bool SodaRecognitionResult_FinalResultEndpointReason_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SodaRecognitionResult_FinalResultEndpointReason* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      SodaRecognitionResult_FinalResultEndpointReason_entries, 7, name, &int_value);
  if (success) {
    *value = static_cast<SodaRecognitionResult_FinalResultEndpointReason>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr SodaRecognitionResult_FinalResultEndpointReason SodaRecognitionResult::ENDPOINT_UNKNOWN;
constexpr SodaRecognitionResult_FinalResultEndpointReason SodaRecognitionResult::ENDPOINT_END_OF_SPEECH;
constexpr SodaRecognitionResult_FinalResultEndpointReason SodaRecognitionResult::ENDPOINT_END_OF_UTTERANCE;
constexpr SodaRecognitionResult_FinalResultEndpointReason SodaRecognitionResult::ENDPOINT_END_OF_AUDIO;
constexpr SodaRecognitionResult_FinalResultEndpointReason SodaRecognitionResult::ENDPOINT_ASR_RESET_BY_HOTWORD;
constexpr SodaRecognitionResult_FinalResultEndpointReason SodaRecognitionResult::ENDPOINT_ASR_RESET_EXTERNAL;
constexpr SodaRecognitionResult_FinalResultEndpointReason SodaRecognitionResult::ENDPOINT_ASR_ERROR;
constexpr SodaRecognitionResult_FinalResultEndpointReason SodaRecognitionResult::FinalResultEndpointReason_MIN;
constexpr SodaRecognitionResult_FinalResultEndpointReason SodaRecognitionResult::FinalResultEndpointReason_MAX;
constexpr int SodaRecognitionResult::FinalResultEndpointReason_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool SodaEndpointEvent_EndpointType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> SodaEndpointEvent_EndpointType_strings[5] = {};

static const char SodaEndpointEvent_EndpointType_names[] =
  "END_OF_AUDIO"
  "END_OF_SPEECH"
  "END_OF_UTTERANCE"
  "START_OF_SPEECH"
  "UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry SodaEndpointEvent_EndpointType_entries[] = {
  { {SodaEndpointEvent_EndpointType_names + 0, 12}, 2 },
  { {SodaEndpointEvent_EndpointType_names + 12, 13}, 1 },
  { {SodaEndpointEvent_EndpointType_names + 25, 16}, 3 },
  { {SodaEndpointEvent_EndpointType_names + 41, 15}, 0 },
  { {SodaEndpointEvent_EndpointType_names + 56, 7}, 4 },
};

static const int SodaEndpointEvent_EndpointType_entries_by_number[] = {
  3, // 0 -> START_OF_SPEECH
  1, // 1 -> END_OF_SPEECH
  0, // 2 -> END_OF_AUDIO
  2, // 3 -> END_OF_UTTERANCE
  4, // 4 -> UNKNOWN
};

const std::string& SodaEndpointEvent_EndpointType_Name(
    SodaEndpointEvent_EndpointType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          SodaEndpointEvent_EndpointType_entries,
          SodaEndpointEvent_EndpointType_entries_by_number,
          5, SodaEndpointEvent_EndpointType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      SodaEndpointEvent_EndpointType_entries,
      SodaEndpointEvent_EndpointType_entries_by_number,
      5, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     SodaEndpointEvent_EndpointType_strings[idx].get();
}
bool SodaEndpointEvent_EndpointType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SodaEndpointEvent_EndpointType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      SodaEndpointEvent_EndpointType_entries, 5, name, &int_value);
  if (success) {
    *value = static_cast<SodaEndpointEvent_EndpointType>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr SodaEndpointEvent_EndpointType SodaEndpointEvent::START_OF_SPEECH;
constexpr SodaEndpointEvent_EndpointType SodaEndpointEvent::END_OF_SPEECH;
constexpr SodaEndpointEvent_EndpointType SodaEndpointEvent::END_OF_AUDIO;
constexpr SodaEndpointEvent_EndpointType SodaEndpointEvent::END_OF_UTTERANCE;
constexpr SodaEndpointEvent_EndpointType SodaEndpointEvent::UNKNOWN;
constexpr SodaEndpointEvent_EndpointType SodaEndpointEvent::EndpointType_MIN;
constexpr SodaEndpointEvent_EndpointType SodaEndpointEvent::EndpointType_MAX;
constexpr int SodaEndpointEvent::EndpointType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool SodaResponse_SodaMessageType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> SodaResponse_SodaMessageType_strings[9] = {};

static const char SodaResponse_SodaMessageType_names[] =
  "AUDIO_LEVEL"
  "ENDPOINT"
  "LANGID"
  "LOGS_ONLY_ARTIFICIAL_MESSAGE"
  "RECOGNITION"
  "SHUTDOWN"
  "START"
  "STOP"
  "UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry SodaResponse_SodaMessageType_entries[] = {
  { {SodaResponse_SodaMessageType_names + 0, 11}, 6 },
  { {SodaResponse_SodaMessageType_names + 11, 8}, 5 },
  { {SodaResponse_SodaMessageType_names + 19, 6}, 7 },
  { {SodaResponse_SodaMessageType_names + 25, 28}, 8 },
  { {SodaResponse_SodaMessageType_names + 53, 11}, 1 },
  { {SodaResponse_SodaMessageType_names + 64, 8}, 3 },
  { {SodaResponse_SodaMessageType_names + 72, 5}, 4 },
  { {SodaResponse_SodaMessageType_names + 77, 4}, 2 },
  { {SodaResponse_SodaMessageType_names + 81, 7}, 0 },
};

static const int SodaResponse_SodaMessageType_entries_by_number[] = {
  8, // 0 -> UNKNOWN
  4, // 1 -> RECOGNITION
  7, // 2 -> STOP
  5, // 3 -> SHUTDOWN
  6, // 4 -> START
  1, // 5 -> ENDPOINT
  0, // 6 -> AUDIO_LEVEL
  2, // 7 -> LANGID
  3, // 8 -> LOGS_ONLY_ARTIFICIAL_MESSAGE
};

const std::string& SodaResponse_SodaMessageType_Name(
    SodaResponse_SodaMessageType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          SodaResponse_SodaMessageType_entries,
          SodaResponse_SodaMessageType_entries_by_number,
          9, SodaResponse_SodaMessageType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      SodaResponse_SodaMessageType_entries,
      SodaResponse_SodaMessageType_entries_by_number,
      9, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     SodaResponse_SodaMessageType_strings[idx].get();
}
bool SodaResponse_SodaMessageType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SodaResponse_SodaMessageType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      SodaResponse_SodaMessageType_entries, 9, name, &int_value);
  if (success) {
    *value = static_cast<SodaResponse_SodaMessageType>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr SodaResponse_SodaMessageType SodaResponse::UNKNOWN;
constexpr SodaResponse_SodaMessageType SodaResponse::RECOGNITION;
constexpr SodaResponse_SodaMessageType SodaResponse::STOP;
constexpr SodaResponse_SodaMessageType SodaResponse::SHUTDOWN;
constexpr SodaResponse_SodaMessageType SodaResponse::START;
constexpr SodaResponse_SodaMessageType SodaResponse::ENDPOINT;
constexpr SodaResponse_SodaMessageType SodaResponse::AUDIO_LEVEL;
constexpr SodaResponse_SodaMessageType SodaResponse::LANGID;
constexpr SodaResponse_SodaMessageType SodaResponse::LOGS_ONLY_ARTIFICIAL_MESSAGE;
constexpr SodaResponse_SodaMessageType SodaResponse::SodaMessageType_MIN;
constexpr SodaResponse_SodaMessageType SodaResponse::SodaMessageType_MAX;
constexpr int SodaResponse::SodaMessageType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

// ===================================================================

class ExtendedSodaConfigMsg::_Internal {
 public:
  using HasBits = decltype(std::declval<ExtendedSodaConfigMsg>()._impl_._has_bits_);
  static void set_has_channel_count(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_sample_rate(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_max_buffer_bytes(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_simulate_realtime_testonly(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_config_file_location(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_api_key(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_language_pack_directory(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_recognition_mode(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_reset_on_final_result(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_include_timing_metrics(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_enable_lang_id(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_enable_formatting(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_enable_speaker_change_detection(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_include_logging(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static const ::speech::soda::chrome::MultilangConfig& multilang_config(const ExtendedSodaConfigMsg* msg);
  static void set_has_multilang_config(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

const ::speech::soda::chrome::MultilangConfig&
ExtendedSodaConfigMsg::_Internal::multilang_config(const ExtendedSodaConfigMsg* msg) {
  return *msg->_impl_.multilang_config_;
}
ExtendedSodaConfigMsg::ExtendedSodaConfigMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:speech.soda.chrome.ExtendedSodaConfigMsg)
}
ExtendedSodaConfigMsg::ExtendedSodaConfigMsg(const ExtendedSodaConfigMsg& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  ExtendedSodaConfigMsg* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.config_file_location_){}
    , decltype(_impl_.api_key_){}
    , decltype(_impl_.language_pack_directory_){}
    , decltype(_impl_.multilang_config_){nullptr}
    , decltype(_impl_.channel_count_){}
    , decltype(_impl_.sample_rate_){}
    , decltype(_impl_.max_buffer_bytes_){}
    , decltype(_impl_.simulate_realtime_testonly_){}
    , decltype(_impl_.enable_lang_id_){}
    , decltype(_impl_.enable_speaker_change_detection_){}
    , decltype(_impl_.include_logging_){}
    , decltype(_impl_.recognition_mode_){}
    , decltype(_impl_.reset_on_final_result_){}
    , decltype(_impl_.include_timing_metrics_){}
    , decltype(_impl_.enable_formatting_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.config_file_location_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.config_file_location_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_config_file_location()) {
    _this->_impl_.config_file_location_.Set(from._internal_config_file_location(), 
      _this->GetArenaForAllocation());
  }
  _impl_.api_key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.api_key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_api_key()) {
    _this->_impl_.api_key_.Set(from._internal_api_key(), 
      _this->GetArenaForAllocation());
  }
  _impl_.language_pack_directory_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.language_pack_directory_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_language_pack_directory()) {
    _this->_impl_.language_pack_directory_.Set(from._internal_language_pack_directory(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_multilang_config()) {
    _this->_impl_.multilang_config_ = new ::speech::soda::chrome::MultilangConfig(*from._impl_.multilang_config_);
  }
  ::memcpy(&_impl_.channel_count_, &from._impl_.channel_count_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.enable_formatting_) -
    reinterpret_cast<char*>(&_impl_.channel_count_)) + sizeof(_impl_.enable_formatting_));
  // @@protoc_insertion_point(copy_constructor:speech.soda.chrome.ExtendedSodaConfigMsg)
}

inline void ExtendedSodaConfigMsg::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.config_file_location_){}
    , decltype(_impl_.api_key_){}
    , decltype(_impl_.language_pack_directory_){}
    , decltype(_impl_.multilang_config_){nullptr}
    , decltype(_impl_.channel_count_){0}
    , decltype(_impl_.sample_rate_){0}
    , decltype(_impl_.max_buffer_bytes_){0}
    , decltype(_impl_.simulate_realtime_testonly_){false}
    , decltype(_impl_.enable_lang_id_){false}
    , decltype(_impl_.enable_speaker_change_detection_){false}
    , decltype(_impl_.include_logging_){false}
    , decltype(_impl_.recognition_mode_){1}
    , decltype(_impl_.reset_on_final_result_){true}
    , decltype(_impl_.include_timing_metrics_){true}
    , decltype(_impl_.enable_formatting_){true}
  };
  _impl_.config_file_location_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.config_file_location_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.api_key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.api_key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.language_pack_directory_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.language_pack_directory_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ExtendedSodaConfigMsg::~ExtendedSodaConfigMsg() {
  // @@protoc_insertion_point(destructor:speech.soda.chrome.ExtendedSodaConfigMsg)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ExtendedSodaConfigMsg::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.config_file_location_.Destroy();
  _impl_.api_key_.Destroy();
  _impl_.language_pack_directory_.Destroy();
  if (this != internal_default_instance()) delete _impl_.multilang_config_;
}

void ExtendedSodaConfigMsg::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ExtendedSodaConfigMsg::Clear() {
// @@protoc_insertion_point(message_clear_start:speech.soda.chrome.ExtendedSodaConfigMsg)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.config_file_location_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.api_key_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.language_pack_directory_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.multilang_config_ != nullptr);
      _impl_.multilang_config_->Clear();
    }
  }
  if (cached_has_bits & 0x000000f0u) {
    ::memset(&_impl_.channel_count_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.simulate_realtime_testonly_) -
        reinterpret_cast<char*>(&_impl_.channel_count_)) + sizeof(_impl_.simulate_realtime_testonly_));
  }
  if (cached_has_bits & 0x00007f00u) {
    ::memset(&_impl_.enable_lang_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.include_logging_) -
        reinterpret_cast<char*>(&_impl_.enable_lang_id_)) + sizeof(_impl_.include_logging_));
    _impl_.recognition_mode_ = 1;
    _impl_.reset_on_final_result_ = true;
    _impl_.include_timing_metrics_ = true;
    _impl_.enable_formatting_ = true;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ExtendedSodaConfigMsg::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 channel_count = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_channel_count(&has_bits);
          _impl_.channel_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 sample_rate = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_sample_rate(&has_bits);
          _impl_.sample_rate_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string config_file_location = 3 [deprecated = true];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_config_file_location();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 max_buffer_bytes = 4 [default = 0];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_max_buffer_bytes(&has_bits);
          _impl_.max_buffer_bytes_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool simulate_realtime_testonly = 5 [default = false];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_simulate_realtime_testonly(&has_bits);
          _impl_.simulate_realtime_testonly_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string api_key = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_api_key();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string language_pack_directory = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_language_pack_directory();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .speech.soda.chrome.ExtendedSodaConfigMsg.RecognitionMode recognition_mode = 8 [default = IME];
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::speech::soda::chrome::ExtendedSodaConfigMsg_RecognitionMode_IsValid(val))) {
            _internal_set_recognition_mode(static_cast<::speech::soda::chrome::ExtendedSodaConfigMsg_RecognitionMode>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(8, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional bool reset_on_final_result = 9 [default = true, deprecated = true];
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_reset_on_final_result(&has_bits);
          _impl_.reset_on_final_result_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool include_timing_metrics = 10 [default = true];
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_include_timing_metrics(&has_bits);
          _impl_.include_timing_metrics_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool enable_lang_id = 11 [default = false];
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _Internal::set_has_enable_lang_id(&has_bits);
          _impl_.enable_lang_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool enable_formatting = 12 [default = true];
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _Internal::set_has_enable_formatting(&has_bits);
          _impl_.enable_formatting_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool enable_speaker_change_detection = 13 [default = false];
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          _Internal::set_has_enable_speaker_change_detection(&has_bits);
          _impl_.enable_speaker_change_detection_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool include_logging = 14 [default = false];
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
          _Internal::set_has_include_logging(&has_bits);
          _impl_.include_logging_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .speech.soda.chrome.MultilangConfig multilang_config = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 122)) {
          ptr = ctx->ParseMessage(_internal_mutable_multilang_config(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ExtendedSodaConfigMsg::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:speech.soda.chrome.ExtendedSodaConfigMsg)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 channel_count = 1;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_channel_count(), target);
  }

  // optional int32 sample_rate = 2;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_sample_rate(), target);
  }

  // optional string config_file_location = 3 [deprecated = true];
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_config_file_location(), target);
  }

  // optional int32 max_buffer_bytes = 4 [default = 0];
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_max_buffer_bytes(), target);
  }

  // optional bool simulate_realtime_testonly = 5 [default = false];
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(5, this->_internal_simulate_realtime_testonly(), target);
  }

  // optional string api_key = 6;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_api_key(), target);
  }

  // optional string language_pack_directory = 7;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteStringMaybeAliased(
        7, this->_internal_language_pack_directory(), target);
  }

  // optional .speech.soda.chrome.ExtendedSodaConfigMsg.RecognitionMode recognition_mode = 8 [default = IME];
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      8, this->_internal_recognition_mode(), target);
  }

  // optional bool reset_on_final_result = 9 [default = true, deprecated = true];
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(9, this->_internal_reset_on_final_result(), target);
  }

  // optional bool include_timing_metrics = 10 [default = true];
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(10, this->_internal_include_timing_metrics(), target);
  }

  // optional bool enable_lang_id = 11 [default = false];
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(11, this->_internal_enable_lang_id(), target);
  }

  // optional bool enable_formatting = 12 [default = true];
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(12, this->_internal_enable_formatting(), target);
  }

  // optional bool enable_speaker_change_detection = 13 [default = false];
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(13, this->_internal_enable_speaker_change_detection(), target);
  }

  // optional bool include_logging = 14 [default = false];
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(14, this->_internal_include_logging(), target);
  }

  // optional .speech.soda.chrome.MultilangConfig multilang_config = 15;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(15, _Internal::multilang_config(this),
        _Internal::multilang_config(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:speech.soda.chrome.ExtendedSodaConfigMsg)
  return target;
}

size_t ExtendedSodaConfigMsg::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:speech.soda.chrome.ExtendedSodaConfigMsg)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string config_file_location = 3 [deprecated = true];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_config_file_location());
    }

    // optional string api_key = 6;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_api_key());
    }

    // optional string language_pack_directory = 7;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_language_pack_directory());
    }

    // optional .speech.soda.chrome.MultilangConfig multilang_config = 15;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.multilang_config_);
    }

    // optional int32 channel_count = 1;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_channel_count());
    }

    // optional int32 sample_rate = 2;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_sample_rate());
    }

    // optional int32 max_buffer_bytes = 4 [default = 0];
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_max_buffer_bytes());
    }

    // optional bool simulate_realtime_testonly = 5 [default = false];
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 1;
    }

  }
  if (cached_has_bits & 0x00007f00u) {
    // optional bool enable_lang_id = 11 [default = false];
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 + 1;
    }

    // optional bool enable_speaker_change_detection = 13 [default = false];
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 + 1;
    }

    // optional bool include_logging = 14 [default = false];
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 + 1;
    }

    // optional .speech.soda.chrome.ExtendedSodaConfigMsg.RecognitionMode recognition_mode = 8 [default = IME];
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_recognition_mode());
    }

    // optional bool reset_on_final_result = 9 [default = true, deprecated = true];
    if (cached_has_bits & 0x00001000u) {
      total_size += 1 + 1;
    }

    // optional bool include_timing_metrics = 10 [default = true];
    if (cached_has_bits & 0x00002000u) {
      total_size += 1 + 1;
    }

    // optional bool enable_formatting = 12 [default = true];
    if (cached_has_bits & 0x00004000u) {
      total_size += 1 + 1;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ExtendedSodaConfigMsg::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ExtendedSodaConfigMsg*>(
      &from));
}

void ExtendedSodaConfigMsg::MergeFrom(const ExtendedSodaConfigMsg& from) {
  ExtendedSodaConfigMsg* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:speech.soda.chrome.ExtendedSodaConfigMsg)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_config_file_location(from._internal_config_file_location());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_api_key(from._internal_api_key());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_language_pack_directory(from._internal_language_pack_directory());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_multilang_config()->::speech::soda::chrome::MultilangConfig::MergeFrom(
          from._internal_multilang_config());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.channel_count_ = from._impl_.channel_count_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.sample_rate_ = from._impl_.sample_rate_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.max_buffer_bytes_ = from._impl_.max_buffer_bytes_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.simulate_realtime_testonly_ = from._impl_.simulate_realtime_testonly_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00007f00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.enable_lang_id_ = from._impl_.enable_lang_id_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.enable_speaker_change_detection_ = from._impl_.enable_speaker_change_detection_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.include_logging_ = from._impl_.include_logging_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.recognition_mode_ = from._impl_.recognition_mode_;
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_impl_.reset_on_final_result_ = from._impl_.reset_on_final_result_;
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_impl_.include_timing_metrics_ = from._impl_.include_timing_metrics_;
    }
    if (cached_has_bits & 0x00004000u) {
      _this->_impl_.enable_formatting_ = from._impl_.enable_formatting_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ExtendedSodaConfigMsg::CopyFrom(const ExtendedSodaConfigMsg& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:speech.soda.chrome.ExtendedSodaConfigMsg)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ExtendedSodaConfigMsg::IsInitialized() const {
  return true;
}

void ExtendedSodaConfigMsg::InternalSwap(ExtendedSodaConfigMsg* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.config_file_location_, lhs_arena,
      &other->_impl_.config_file_location_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.api_key_, lhs_arena,
      &other->_impl_.api_key_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.language_pack_directory_, lhs_arena,
      &other->_impl_.language_pack_directory_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ExtendedSodaConfigMsg, _impl_.include_logging_)
      + sizeof(ExtendedSodaConfigMsg::_impl_.include_logging_)
      - PROTOBUF_FIELD_OFFSET(ExtendedSodaConfigMsg, _impl_.multilang_config_)>(
          reinterpret_cast<char*>(&_impl_.multilang_config_),
          reinterpret_cast<char*>(&other->_impl_.multilang_config_));
  swap(_impl_.recognition_mode_, other->_impl_.recognition_mode_);
  swap(_impl_.reset_on_final_result_, other->_impl_.reset_on_final_result_);
  swap(_impl_.include_timing_metrics_, other->_impl_.include_timing_metrics_);
  swap(_impl_.enable_formatting_, other->_impl_.enable_formatting_);
}

std::string ExtendedSodaConfigMsg::GetTypeName() const {
  return "speech.soda.chrome.ExtendedSodaConfigMsg";
}


// ===================================================================

MultilangConfig_MultilangLanguagePackDirectoryEntry_DoNotUse::MultilangConfig_MultilangLanguagePackDirectoryEntry_DoNotUse() {}
MultilangConfig_MultilangLanguagePackDirectoryEntry_DoNotUse::MultilangConfig_MultilangLanguagePackDirectoryEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void MultilangConfig_MultilangLanguagePackDirectoryEntry_DoNotUse::MergeFrom(const MultilangConfig_MultilangLanguagePackDirectoryEntry_DoNotUse& other) {
  MergeFromInternal(other);
}

// ===================================================================

class MultilangConfig::_Internal {
 public:
  using HasBits = decltype(std::declval<MultilangConfig>()._impl_._has_bits_);
  static void set_has_rewind_when_switching_language(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

MultilangConfig::MultilangConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:speech.soda.chrome.MultilangConfig)
}
MultilangConfig::MultilangConfig(const MultilangConfig& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  MultilangConfig* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_.multilang_language_pack_directory_)*/{}
    , decltype(_impl_.rewind_when_switching_language_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.multilang_language_pack_directory_.MergeFrom(from._impl_.multilang_language_pack_directory_);
  _this->_impl_.rewind_when_switching_language_ = from._impl_.rewind_when_switching_language_;
  // @@protoc_insertion_point(copy_constructor:speech.soda.chrome.MultilangConfig)
}

inline void MultilangConfig::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_.multilang_language_pack_directory_)*/{::_pbi::ArenaInitialized(), arena}
    , decltype(_impl_.rewind_when_switching_language_){false}
  };
}

MultilangConfig::~MultilangConfig() {
  // @@protoc_insertion_point(destructor:speech.soda.chrome.MultilangConfig)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MultilangConfig::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.multilang_language_pack_directory_.Destruct();
  _impl_.multilang_language_pack_directory_.~MapFieldLite();
}

void MultilangConfig::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MultilangConfig::Clear() {
// @@protoc_insertion_point(message_clear_start:speech.soda.chrome.MultilangConfig)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.multilang_language_pack_directory_.Clear();
  _impl_.rewind_when_switching_language_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* MultilangConfig::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // map<string, string> multilang_language_pack_directory = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&_impl_.multilang_language_pack_directory_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional bool rewind_when_switching_language = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_rewind_when_switching_language(&has_bits);
          _impl_.rewind_when_switching_language_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MultilangConfig::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:speech.soda.chrome.MultilangConfig)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // map<string, string> multilang_language_pack_directory = 1;
  if (!this->_internal_multilang_language_pack_directory().empty()) {
    using MapType = ::_pb::Map<std::string, std::string>;
    using WireHelper = MultilangConfig_MultilangLanguagePackDirectoryEntry_DoNotUse::Funcs;
    const auto& map_field = this->_internal_multilang_language_pack_directory();
    auto check_utf8 = [](const MapType::value_type& entry) {
      (void)entry;
    };

    if (stream->IsSerializationDeterministic() && map_field.size() > 1) {
      for (const auto& entry : ::_pbi::MapSorterPtr<MapType>(map_field)) {
        target = WireHelper::InternalSerialize(1, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    } else {
      for (const auto& entry : map_field) {
        target = WireHelper::InternalSerialize(1, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    }
  }

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool rewind_when_switching_language = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_rewind_when_switching_language(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:speech.soda.chrome.MultilangConfig)
  return target;
}

size_t MultilangConfig::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:speech.soda.chrome.MultilangConfig)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // map<string, string> multilang_language_pack_directory = 1;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_multilang_language_pack_directory_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >::const_iterator
      it = this->_internal_multilang_language_pack_directory().begin();
      it != this->_internal_multilang_language_pack_directory().end(); ++it) {
    total_size += MultilangConfig_MultilangLanguagePackDirectoryEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  // optional bool rewind_when_switching_language = 2;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 1;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void MultilangConfig::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const MultilangConfig*>(
      &from));
}

void MultilangConfig::MergeFrom(const MultilangConfig& from) {
  MultilangConfig* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:speech.soda.chrome.MultilangConfig)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.multilang_language_pack_directory_.MergeFrom(from._impl_.multilang_language_pack_directory_);
  if (from._internal_has_rewind_when_switching_language()) {
    _this->_internal_set_rewind_when_switching_language(from._internal_rewind_when_switching_language());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void MultilangConfig::CopyFrom(const MultilangConfig& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:speech.soda.chrome.MultilangConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MultilangConfig::IsInitialized() const {
  return true;
}

void MultilangConfig::InternalSwap(MultilangConfig* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.multilang_language_pack_directory_.InternalSwap(&other->_impl_.multilang_language_pack_directory_);
  swap(_impl_.rewind_when_switching_language_, other->_impl_.rewind_when_switching_language_);
}

std::string MultilangConfig::GetTypeName() const {
  return "speech.soda.chrome.MultilangConfig";
}


// ===================================================================

class TimingMetrics::_Internal {
 public:
  using HasBits = decltype(std::declval<TimingMetrics>()._impl_._has_bits_);
  static void set_has_audio_start_epoch_usec(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_audio_start_time_usec(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_elapsed_wall_time_usec(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_event_end_time_usec(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

TimingMetrics::TimingMetrics(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:speech.soda.chrome.TimingMetrics)
}
TimingMetrics::TimingMetrics(const TimingMetrics& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  TimingMetrics* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.audio_start_epoch_usec_){}
    , decltype(_impl_.audio_start_time_usec_){}
    , decltype(_impl_.elapsed_wall_time_usec_){}
    , decltype(_impl_.event_end_time_usec_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.audio_start_epoch_usec_, &from._impl_.audio_start_epoch_usec_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.event_end_time_usec_) -
    reinterpret_cast<char*>(&_impl_.audio_start_epoch_usec_)) + sizeof(_impl_.event_end_time_usec_));
  // @@protoc_insertion_point(copy_constructor:speech.soda.chrome.TimingMetrics)
}

inline void TimingMetrics::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.audio_start_epoch_usec_){int64_t{0}}
    , decltype(_impl_.audio_start_time_usec_){int64_t{0}}
    , decltype(_impl_.elapsed_wall_time_usec_){int64_t{0}}
    , decltype(_impl_.event_end_time_usec_){int64_t{0}}
  };
}

TimingMetrics::~TimingMetrics() {
  // @@protoc_insertion_point(destructor:speech.soda.chrome.TimingMetrics)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TimingMetrics::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void TimingMetrics::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TimingMetrics::Clear() {
// @@protoc_insertion_point(message_clear_start:speech.soda.chrome.TimingMetrics)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&_impl_.audio_start_epoch_usec_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.event_end_time_usec_) -
        reinterpret_cast<char*>(&_impl_.audio_start_epoch_usec_)) + sizeof(_impl_.event_end_time_usec_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* TimingMetrics::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int64 audio_start_epoch_usec = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_audio_start_epoch_usec(&has_bits);
          _impl_.audio_start_epoch_usec_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 audio_start_time_usec = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_audio_start_time_usec(&has_bits);
          _impl_.audio_start_time_usec_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 elapsed_wall_time_usec = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_elapsed_wall_time_usec(&has_bits);
          _impl_.elapsed_wall_time_usec_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 event_end_time_usec = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_event_end_time_usec(&has_bits);
          _impl_.event_end_time_usec_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TimingMetrics::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:speech.soda.chrome.TimingMetrics)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int64 audio_start_epoch_usec = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_audio_start_epoch_usec(), target);
  }

  // optional int64 audio_start_time_usec = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(2, this->_internal_audio_start_time_usec(), target);
  }

  // optional int64 elapsed_wall_time_usec = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(3, this->_internal_elapsed_wall_time_usec(), target);
  }

  // optional int64 event_end_time_usec = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(4, this->_internal_event_end_time_usec(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:speech.soda.chrome.TimingMetrics)
  return target;
}

size_t TimingMetrics::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:speech.soda.chrome.TimingMetrics)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional int64 audio_start_epoch_usec = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_audio_start_epoch_usec());
    }

    // optional int64 audio_start_time_usec = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_audio_start_time_usec());
    }

    // optional int64 elapsed_wall_time_usec = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_elapsed_wall_time_usec());
    }

    // optional int64 event_end_time_usec = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_event_end_time_usec());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TimingMetrics::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const TimingMetrics*>(
      &from));
}

void TimingMetrics::MergeFrom(const TimingMetrics& from) {
  TimingMetrics* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:speech.soda.chrome.TimingMetrics)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.audio_start_epoch_usec_ = from._impl_.audio_start_epoch_usec_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.audio_start_time_usec_ = from._impl_.audio_start_time_usec_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.elapsed_wall_time_usec_ = from._impl_.elapsed_wall_time_usec_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.event_end_time_usec_ = from._impl_.event_end_time_usec_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TimingMetrics::CopyFrom(const TimingMetrics& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:speech.soda.chrome.TimingMetrics)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TimingMetrics::IsInitialized() const {
  return true;
}

void TimingMetrics::InternalSwap(TimingMetrics* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TimingMetrics, _impl_.event_end_time_usec_)
      + sizeof(TimingMetrics::_impl_.event_end_time_usec_)
      - PROTOBUF_FIELD_OFFSET(TimingMetrics, _impl_.audio_start_epoch_usec_)>(
          reinterpret_cast<char*>(&_impl_.audio_start_epoch_usec_),
          reinterpret_cast<char*>(&other->_impl_.audio_start_epoch_usec_));
}

std::string TimingMetrics::GetTypeName() const {
  return "speech.soda.chrome.TimingMetrics";
}


// ===================================================================

class HypothesisPart::_Internal {
 public:
  using HasBits = decltype(std::declval<HypothesisPart>()._impl_._has_bits_);
  static void set_has_alignment_ms(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

HypothesisPart::HypothesisPart(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:speech.soda.chrome.HypothesisPart)
}
HypothesisPart::HypothesisPart(const HypothesisPart& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  HypothesisPart* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.text_){from._impl_.text_}
    , decltype(_impl_.alignment_ms_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _this->_impl_.alignment_ms_ = from._impl_.alignment_ms_;
  // @@protoc_insertion_point(copy_constructor:speech.soda.chrome.HypothesisPart)
}

inline void HypothesisPart::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.text_){arena}
    , decltype(_impl_.alignment_ms_){int64_t{0}}
  };
}

HypothesisPart::~HypothesisPart() {
  // @@protoc_insertion_point(destructor:speech.soda.chrome.HypothesisPart)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void HypothesisPart::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.text_.~RepeatedPtrField();
}

void HypothesisPart::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void HypothesisPart::Clear() {
// @@protoc_insertion_point(message_clear_start:speech.soda.chrome.HypothesisPart)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.text_.Clear();
  _impl_.alignment_ms_ = int64_t{0};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* HypothesisPart::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated string text = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_text();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional int64 alignment_ms = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_alignment_ms(&has_bits);
          _impl_.alignment_ms_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* HypothesisPart::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:speech.soda.chrome.HypothesisPart)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated string text = 1;
  for (int i = 0, n = this->_internal_text_size(); i < n; i++) {
    const auto& s = this->_internal_text(i);
    target = stream->WriteString(1, s, target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // optional int64 alignment_ms = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(2, this->_internal_alignment_ms(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:speech.soda.chrome.HypothesisPart)
  return target;
}

size_t HypothesisPart::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:speech.soda.chrome.HypothesisPart)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string text = 1;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.text_.size());
  for (int i = 0, n = _impl_.text_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.text_.Get(i));
  }

  // optional int64 alignment_ms = 2;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_alignment_ms());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void HypothesisPart::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const HypothesisPart*>(
      &from));
}

void HypothesisPart::MergeFrom(const HypothesisPart& from) {
  HypothesisPart* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:speech.soda.chrome.HypothesisPart)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.text_.MergeFrom(from._impl_.text_);
  if (from._internal_has_alignment_ms()) {
    _this->_internal_set_alignment_ms(from._internal_alignment_ms());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void HypothesisPart::CopyFrom(const HypothesisPart& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:speech.soda.chrome.HypothesisPart)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool HypothesisPart::IsInitialized() const {
  return true;
}

void HypothesisPart::InternalSwap(HypothesisPart* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.text_.InternalSwap(&other->_impl_.text_);
  swap(_impl_.alignment_ms_, other->_impl_.alignment_ms_);
}

std::string HypothesisPart::GetTypeName() const {
  return "speech.soda.chrome.HypothesisPart";
}


// ===================================================================

class SodaRecognitionResult::_Internal {
 public:
  using HasBits = decltype(std::declval<SodaRecognitionResult>()._impl_._has_bits_);
  static void set_has_result_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_endpoint_reason(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::speech::soda::chrome::TimingMetrics& timing_metrics(const SodaRecognitionResult* msg);
  static void set_has_timing_metrics(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::speech::soda::chrome::TimingMetrics&
SodaRecognitionResult::_Internal::timing_metrics(const SodaRecognitionResult* msg) {
  return *msg->_impl_.timing_metrics_;
}
SodaRecognitionResult::SodaRecognitionResult(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:speech.soda.chrome.SodaRecognitionResult)
}
SodaRecognitionResult::SodaRecognitionResult(const SodaRecognitionResult& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  SodaRecognitionResult* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.hypothesis_){from._impl_.hypothesis_}
    , decltype(_impl_.hypothesis_part_){from._impl_.hypothesis_part_}
    , decltype(_impl_.timing_metrics_){nullptr}
    , decltype(_impl_.result_type_){}
    , decltype(_impl_.endpoint_reason_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_timing_metrics()) {
    _this->_impl_.timing_metrics_ = new ::speech::soda::chrome::TimingMetrics(*from._impl_.timing_metrics_);
  }
  ::memcpy(&_impl_.result_type_, &from._impl_.result_type_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.endpoint_reason_) -
    reinterpret_cast<char*>(&_impl_.result_type_)) + sizeof(_impl_.endpoint_reason_));
  // @@protoc_insertion_point(copy_constructor:speech.soda.chrome.SodaRecognitionResult)
}

inline void SodaRecognitionResult::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.hypothesis_){arena}
    , decltype(_impl_.hypothesis_part_){arena}
    , decltype(_impl_.timing_metrics_){nullptr}
    , decltype(_impl_.result_type_){0}
    , decltype(_impl_.endpoint_reason_){0}
  };
}

SodaRecognitionResult::~SodaRecognitionResult() {
  // @@protoc_insertion_point(destructor:speech.soda.chrome.SodaRecognitionResult)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SodaRecognitionResult::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.hypothesis_.~RepeatedPtrField();
  _impl_.hypothesis_part_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.timing_metrics_;
}

void SodaRecognitionResult::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SodaRecognitionResult::Clear() {
// @@protoc_insertion_point(message_clear_start:speech.soda.chrome.SodaRecognitionResult)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.hypothesis_.Clear();
  _impl_.hypothesis_part_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.timing_metrics_ != nullptr);
    _impl_.timing_metrics_->Clear();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.result_type_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.endpoint_reason_) -
        reinterpret_cast<char*>(&_impl_.result_type_)) + sizeof(_impl_.endpoint_reason_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* SodaRecognitionResult::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated string hypothesis = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_hypothesis();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .speech.soda.chrome.SodaRecognitionResult.ResultType result_type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::speech::soda::chrome::SodaRecognitionResult_ResultType_IsValid(val))) {
            _internal_set_result_type(static_cast<::speech::soda::chrome::SodaRecognitionResult_ResultType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .speech.soda.chrome.SodaRecognitionResult.FinalResultEndpointReason endpoint_reason = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::speech::soda::chrome::SodaRecognitionResult_FinalResultEndpointReason_IsValid(val))) {
            _internal_set_endpoint_reason(static_cast<::speech::soda::chrome::SodaRecognitionResult_FinalResultEndpointReason>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .speech.soda.chrome.TimingMetrics timing_metrics = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_timing_metrics(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .speech.soda.chrome.HypothesisPart hypothesis_part = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_hypothesis_part(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SodaRecognitionResult::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:speech.soda.chrome.SodaRecognitionResult)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated string hypothesis = 1;
  for (int i = 0, n = this->_internal_hypothesis_size(); i < n; i++) {
    const auto& s = this->_internal_hypothesis(i);
    target = stream->WriteString(1, s, target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // optional .speech.soda.chrome.SodaRecognitionResult.ResultType result_type = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_result_type(), target);
  }

  // optional .speech.soda.chrome.SodaRecognitionResult.FinalResultEndpointReason endpoint_reason = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_endpoint_reason(), target);
  }

  // optional .speech.soda.chrome.TimingMetrics timing_metrics = 4;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::timing_metrics(this),
        _Internal::timing_metrics(this).GetCachedSize(), target, stream);
  }

  // repeated .speech.soda.chrome.HypothesisPart hypothesis_part = 5;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_hypothesis_part_size()); i < n; i++) {
    const auto& repfield = this->_internal_hypothesis_part(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(5, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:speech.soda.chrome.SodaRecognitionResult)
  return target;
}

size_t SodaRecognitionResult::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:speech.soda.chrome.SodaRecognitionResult)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string hypothesis = 1;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.hypothesis_.size());
  for (int i = 0, n = _impl_.hypothesis_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.hypothesis_.Get(i));
  }

  // repeated .speech.soda.chrome.HypothesisPart hypothesis_part = 5;
  total_size += 1UL * this->_internal_hypothesis_part_size();
  for (const auto& msg : this->_impl_.hypothesis_part_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .speech.soda.chrome.TimingMetrics timing_metrics = 4;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.timing_metrics_);
    }

    // optional .speech.soda.chrome.SodaRecognitionResult.ResultType result_type = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_result_type());
    }

    // optional .speech.soda.chrome.SodaRecognitionResult.FinalResultEndpointReason endpoint_reason = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_endpoint_reason());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SodaRecognitionResult::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const SodaRecognitionResult*>(
      &from));
}

void SodaRecognitionResult::MergeFrom(const SodaRecognitionResult& from) {
  SodaRecognitionResult* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:speech.soda.chrome.SodaRecognitionResult)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.hypothesis_.MergeFrom(from._impl_.hypothesis_);
  _this->_impl_.hypothesis_part_.MergeFrom(from._impl_.hypothesis_part_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_timing_metrics()->::speech::soda::chrome::TimingMetrics::MergeFrom(
          from._internal_timing_metrics());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.result_type_ = from._impl_.result_type_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.endpoint_reason_ = from._impl_.endpoint_reason_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SodaRecognitionResult::CopyFrom(const SodaRecognitionResult& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:speech.soda.chrome.SodaRecognitionResult)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SodaRecognitionResult::IsInitialized() const {
  return true;
}

void SodaRecognitionResult::InternalSwap(SodaRecognitionResult* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.hypothesis_.InternalSwap(&other->_impl_.hypothesis_);
  _impl_.hypothesis_part_.InternalSwap(&other->_impl_.hypothesis_part_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SodaRecognitionResult, _impl_.endpoint_reason_)
      + sizeof(SodaRecognitionResult::_impl_.endpoint_reason_)
      - PROTOBUF_FIELD_OFFSET(SodaRecognitionResult, _impl_.timing_metrics_)>(
          reinterpret_cast<char*>(&_impl_.timing_metrics_),
          reinterpret_cast<char*>(&other->_impl_.timing_metrics_));
}

std::string SodaRecognitionResult::GetTypeName() const {
  return "speech.soda.chrome.SodaRecognitionResult";
}


// ===================================================================

class SodaEndpointEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<SodaEndpointEvent>()._impl_._has_bits_);
  static void set_has_endpoint_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::speech::soda::chrome::TimingMetrics& timing_metrics(const SodaEndpointEvent* msg);
  static void set_has_timing_metrics(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::speech::soda::chrome::TimingMetrics&
SodaEndpointEvent::_Internal::timing_metrics(const SodaEndpointEvent* msg) {
  return *msg->_impl_.timing_metrics_;
}
SodaEndpointEvent::SodaEndpointEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:speech.soda.chrome.SodaEndpointEvent)
}
SodaEndpointEvent::SodaEndpointEvent(const SodaEndpointEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  SodaEndpointEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.timing_metrics_){nullptr}
    , decltype(_impl_.endpoint_type_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_timing_metrics()) {
    _this->_impl_.timing_metrics_ = new ::speech::soda::chrome::TimingMetrics(*from._impl_.timing_metrics_);
  }
  _this->_impl_.endpoint_type_ = from._impl_.endpoint_type_;
  // @@protoc_insertion_point(copy_constructor:speech.soda.chrome.SodaEndpointEvent)
}

inline void SodaEndpointEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.timing_metrics_){nullptr}
    , decltype(_impl_.endpoint_type_){4}
  };
}

SodaEndpointEvent::~SodaEndpointEvent() {
  // @@protoc_insertion_point(destructor:speech.soda.chrome.SodaEndpointEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SodaEndpointEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.timing_metrics_;
}

void SodaEndpointEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SodaEndpointEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:speech.soda.chrome.SodaEndpointEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.timing_metrics_ != nullptr);
      _impl_.timing_metrics_->Clear();
    }
    _impl_.endpoint_type_ = 4;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* SodaEndpointEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .speech.soda.chrome.SodaEndpointEvent.EndpointType endpoint_type = 1 [default = UNKNOWN];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::speech::soda::chrome::SodaEndpointEvent_EndpointType_IsValid(val))) {
            _internal_set_endpoint_type(static_cast<::speech::soda::chrome::SodaEndpointEvent_EndpointType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .speech.soda.chrome.TimingMetrics timing_metrics = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_timing_metrics(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SodaEndpointEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:speech.soda.chrome.SodaEndpointEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .speech.soda.chrome.SodaEndpointEvent.EndpointType endpoint_type = 1 [default = UNKNOWN];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_endpoint_type(), target);
  }

  // optional .speech.soda.chrome.TimingMetrics timing_metrics = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::timing_metrics(this),
        _Internal::timing_metrics(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:speech.soda.chrome.SodaEndpointEvent)
  return target;
}

size_t SodaEndpointEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:speech.soda.chrome.SodaEndpointEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .speech.soda.chrome.TimingMetrics timing_metrics = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.timing_metrics_);
    }

    // optional .speech.soda.chrome.SodaEndpointEvent.EndpointType endpoint_type = 1 [default = UNKNOWN];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_endpoint_type());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SodaEndpointEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const SodaEndpointEvent*>(
      &from));
}

void SodaEndpointEvent::MergeFrom(const SodaEndpointEvent& from) {
  SodaEndpointEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:speech.soda.chrome.SodaEndpointEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_timing_metrics()->::speech::soda::chrome::TimingMetrics::MergeFrom(
          from._internal_timing_metrics());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.endpoint_type_ = from._impl_.endpoint_type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SodaEndpointEvent::CopyFrom(const SodaEndpointEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:speech.soda.chrome.SodaEndpointEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SodaEndpointEvent::IsInitialized() const {
  return true;
}

void SodaEndpointEvent::InternalSwap(SodaEndpointEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.timing_metrics_, other->_impl_.timing_metrics_);
  swap(_impl_.endpoint_type_, other->_impl_.endpoint_type_);
}

std::string SodaEndpointEvent::GetTypeName() const {
  return "speech.soda.chrome.SodaEndpointEvent";
}


// ===================================================================

class SodaAudioLevelInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<SodaAudioLevelInfo>()._impl_._has_bits_);
  static void set_has_rms(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_audio_level(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_audio_time_usec(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

SodaAudioLevelInfo::SodaAudioLevelInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:speech.soda.chrome.SodaAudioLevelInfo)
}
SodaAudioLevelInfo::SodaAudioLevelInfo(const SodaAudioLevelInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  SodaAudioLevelInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.rms_){}
    , decltype(_impl_.audio_level_){}
    , decltype(_impl_.audio_time_usec_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.rms_, &from._impl_.rms_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.audio_time_usec_) -
    reinterpret_cast<char*>(&_impl_.rms_)) + sizeof(_impl_.audio_time_usec_));
  // @@protoc_insertion_point(copy_constructor:speech.soda.chrome.SodaAudioLevelInfo)
}

inline void SodaAudioLevelInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.rms_){0}
    , decltype(_impl_.audio_level_){0}
    , decltype(_impl_.audio_time_usec_){int64_t{0}}
  };
}

SodaAudioLevelInfo::~SodaAudioLevelInfo() {
  // @@protoc_insertion_point(destructor:speech.soda.chrome.SodaAudioLevelInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SodaAudioLevelInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void SodaAudioLevelInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SodaAudioLevelInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:speech.soda.chrome.SodaAudioLevelInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.rms_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.audio_time_usec_) -
        reinterpret_cast<char*>(&_impl_.rms_)) + sizeof(_impl_.audio_time_usec_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* SodaAudioLevelInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional float rms = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          _Internal::set_has_rms(&has_bits);
          _impl_.rms_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float audio_level = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _Internal::set_has_audio_level(&has_bits);
          _impl_.audio_level_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional int64 audio_time_usec = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_audio_time_usec(&has_bits);
          _impl_.audio_time_usec_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SodaAudioLevelInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:speech.soda.chrome.SodaAudioLevelInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional float rms = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(1, this->_internal_rms(), target);
  }

  // optional float audio_level = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_audio_level(), target);
  }

  // optional int64 audio_time_usec = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(3, this->_internal_audio_time_usec(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:speech.soda.chrome.SodaAudioLevelInfo)
  return target;
}

size_t SodaAudioLevelInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:speech.soda.chrome.SodaAudioLevelInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional float rms = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 4;
    }

    // optional float audio_level = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

    // optional int64 audio_time_usec = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_audio_time_usec());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SodaAudioLevelInfo::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const SodaAudioLevelInfo*>(
      &from));
}

void SodaAudioLevelInfo::MergeFrom(const SodaAudioLevelInfo& from) {
  SodaAudioLevelInfo* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:speech.soda.chrome.SodaAudioLevelInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.rms_ = from._impl_.rms_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.audio_level_ = from._impl_.audio_level_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.audio_time_usec_ = from._impl_.audio_time_usec_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SodaAudioLevelInfo::CopyFrom(const SodaAudioLevelInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:speech.soda.chrome.SodaAudioLevelInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SodaAudioLevelInfo::IsInitialized() const {
  return true;
}

void SodaAudioLevelInfo::InternalSwap(SodaAudioLevelInfo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SodaAudioLevelInfo, _impl_.audio_time_usec_)
      + sizeof(SodaAudioLevelInfo::_impl_.audio_time_usec_)
      - PROTOBUF_FIELD_OFFSET(SodaAudioLevelInfo, _impl_.rms_)>(
          reinterpret_cast<char*>(&_impl_.rms_),
          reinterpret_cast<char*>(&other->_impl_.rms_));
}

std::string SodaAudioLevelInfo::GetTypeName() const {
  return "speech.soda.chrome.SodaAudioLevelInfo";
}


// ===================================================================

class SodaLangIdEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<SodaLangIdEvent>()._impl_._has_bits_);
  static void set_has_language(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_confidence_level(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

SodaLangIdEvent::SodaLangIdEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:speech.soda.chrome.SodaLangIdEvent)
}
SodaLangIdEvent::SodaLangIdEvent(const SodaLangIdEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  SodaLangIdEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.language_){}
    , decltype(_impl_.confidence_level_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.language_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.language_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_language()) {
    _this->_impl_.language_.Set(from._internal_language(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.confidence_level_ = from._impl_.confidence_level_;
  // @@protoc_insertion_point(copy_constructor:speech.soda.chrome.SodaLangIdEvent)
}

inline void SodaLangIdEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.language_){}
    , decltype(_impl_.confidence_level_){0}
  };
  _impl_.language_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.language_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SodaLangIdEvent::~SodaLangIdEvent() {
  // @@protoc_insertion_point(destructor:speech.soda.chrome.SodaLangIdEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SodaLangIdEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.language_.Destroy();
}

void SodaLangIdEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SodaLangIdEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:speech.soda.chrome.SodaLangIdEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.language_.ClearNonDefaultToEmpty();
  }
  _impl_.confidence_level_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* SodaLangIdEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string language = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_language();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 confidence_level = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_confidence_level(&has_bits);
          _impl_.confidence_level_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SodaLangIdEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:speech.soda.chrome.SodaLangIdEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string language = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_language(), target);
  }

  // optional int32 confidence_level = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_confidence_level(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:speech.soda.chrome.SodaLangIdEvent)
  return target;
}

size_t SodaLangIdEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:speech.soda.chrome.SodaLangIdEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string language = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_language());
    }

    // optional int32 confidence_level = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_confidence_level());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SodaLangIdEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const SodaLangIdEvent*>(
      &from));
}

void SodaLangIdEvent::MergeFrom(const SodaLangIdEvent& from) {
  SodaLangIdEvent* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:speech.soda.chrome.SodaLangIdEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_language(from._internal_language());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.confidence_level_ = from._impl_.confidence_level_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SodaLangIdEvent::CopyFrom(const SodaLangIdEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:speech.soda.chrome.SodaLangIdEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SodaLangIdEvent::IsInitialized() const {
  return true;
}

void SodaLangIdEvent::InternalSwap(SodaLangIdEvent* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.language_, lhs_arena,
      &other->_impl_.language_, rhs_arena
  );
  swap(_impl_.confidence_level_, other->_impl_.confidence_level_);
}

std::string SodaLangIdEvent::GetTypeName() const {
  return "speech.soda.chrome.SodaLangIdEvent";
}


// ===================================================================

class SodaResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<SodaResponse>()._impl_._has_bits_);
  static void set_has_soda_type(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::speech::soda::chrome::SodaRecognitionResult& recognition_result(const SodaResponse* msg);
  static void set_has_recognition_result(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::speech::soda::chrome::SodaEndpointEvent& endpoint_event(const SodaResponse* msg);
  static void set_has_endpoint_event(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::speech::soda::chrome::SodaAudioLevelInfo& audio_level_info(const SodaResponse* msg);
  static void set_has_audio_level_info(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::speech::soda::chrome::SodaLangIdEvent& langid_event(const SodaResponse* msg);
  static void set_has_langid_event(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

const ::speech::soda::chrome::SodaRecognitionResult&
SodaResponse::_Internal::recognition_result(const SodaResponse* msg) {
  return *msg->_impl_.recognition_result_;
}
const ::speech::soda::chrome::SodaEndpointEvent&
SodaResponse::_Internal::endpoint_event(const SodaResponse* msg) {
  return *msg->_impl_.endpoint_event_;
}
const ::speech::soda::chrome::SodaAudioLevelInfo&
SodaResponse::_Internal::audio_level_info(const SodaResponse* msg) {
  return *msg->_impl_.audio_level_info_;
}
const ::speech::soda::chrome::SodaLangIdEvent&
SodaResponse::_Internal::langid_event(const SodaResponse* msg) {
  return *msg->_impl_.langid_event_;
}
SodaResponse::SodaResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:speech.soda.chrome.SodaResponse)
}
SodaResponse::SodaResponse(const SodaResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  SodaResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.log_lines_){from._impl_.log_lines_}
    , decltype(_impl_.recognition_result_){nullptr}
    , decltype(_impl_.endpoint_event_){nullptr}
    , decltype(_impl_.audio_level_info_){nullptr}
    , decltype(_impl_.langid_event_){nullptr}
    , decltype(_impl_.soda_type_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_recognition_result()) {
    _this->_impl_.recognition_result_ = new ::speech::soda::chrome::SodaRecognitionResult(*from._impl_.recognition_result_);
  }
  if (from._internal_has_endpoint_event()) {
    _this->_impl_.endpoint_event_ = new ::speech::soda::chrome::SodaEndpointEvent(*from._impl_.endpoint_event_);
  }
  if (from._internal_has_audio_level_info()) {
    _this->_impl_.audio_level_info_ = new ::speech::soda::chrome::SodaAudioLevelInfo(*from._impl_.audio_level_info_);
  }
  if (from._internal_has_langid_event()) {
    _this->_impl_.langid_event_ = new ::speech::soda::chrome::SodaLangIdEvent(*from._impl_.langid_event_);
  }
  _this->_impl_.soda_type_ = from._impl_.soda_type_;
  // @@protoc_insertion_point(copy_constructor:speech.soda.chrome.SodaResponse)
}

inline void SodaResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.log_lines_){arena}
    , decltype(_impl_.recognition_result_){nullptr}
    , decltype(_impl_.endpoint_event_){nullptr}
    , decltype(_impl_.audio_level_info_){nullptr}
    , decltype(_impl_.langid_event_){nullptr}
    , decltype(_impl_.soda_type_){0}
  };
}

SodaResponse::~SodaResponse() {
  // @@protoc_insertion_point(destructor:speech.soda.chrome.SodaResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SodaResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.log_lines_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.recognition_result_;
  if (this != internal_default_instance()) delete _impl_.endpoint_event_;
  if (this != internal_default_instance()) delete _impl_.audio_level_info_;
  if (this != internal_default_instance()) delete _impl_.langid_event_;
}

void SodaResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SodaResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:speech.soda.chrome.SodaResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.log_lines_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.recognition_result_ != nullptr);
      _impl_.recognition_result_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.endpoint_event_ != nullptr);
      _impl_.endpoint_event_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.audio_level_info_ != nullptr);
      _impl_.audio_level_info_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.langid_event_ != nullptr);
      _impl_.langid_event_->Clear();
    }
  }
  _impl_.soda_type_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* SodaResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .speech.soda.chrome.SodaResponse.SodaMessageType soda_type = 1 [default = UNKNOWN];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::speech::soda::chrome::SodaResponse_SodaMessageType_IsValid(val))) {
            _internal_set_soda_type(static_cast<::speech::soda::chrome::SodaResponse_SodaMessageType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .speech.soda.chrome.SodaRecognitionResult recognition_result = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_recognition_result(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .speech.soda.chrome.SodaEndpointEvent endpoint_event = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_endpoint_event(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .speech.soda.chrome.SodaAudioLevelInfo audio_level_info = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_audio_level_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .speech.soda.chrome.SodaLangIdEvent langid_event = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_langid_event(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated string log_lines = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_log_lines();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SodaResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:speech.soda.chrome.SodaResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .speech.soda.chrome.SodaResponse.SodaMessageType soda_type = 1 [default = UNKNOWN];
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_soda_type(), target);
  }

  // optional .speech.soda.chrome.SodaRecognitionResult recognition_result = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::recognition_result(this),
        _Internal::recognition_result(this).GetCachedSize(), target, stream);
  }

  // optional .speech.soda.chrome.SodaEndpointEvent endpoint_event = 3;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::endpoint_event(this),
        _Internal::endpoint_event(this).GetCachedSize(), target, stream);
  }

  // optional .speech.soda.chrome.SodaAudioLevelInfo audio_level_info = 4;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::audio_level_info(this),
        _Internal::audio_level_info(this).GetCachedSize(), target, stream);
  }

  // optional .speech.soda.chrome.SodaLangIdEvent langid_event = 5;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::langid_event(this),
        _Internal::langid_event(this).GetCachedSize(), target, stream);
  }

  // repeated string log_lines = 6;
  for (int i = 0, n = this->_internal_log_lines_size(); i < n; i++) {
    const auto& s = this->_internal_log_lines(i);
    target = stream->WriteString(6, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:speech.soda.chrome.SodaResponse)
  return target;
}

size_t SodaResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:speech.soda.chrome.SodaResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string log_lines = 6;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.log_lines_.size());
  for (int i = 0, n = _impl_.log_lines_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.log_lines_.Get(i));
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional .speech.soda.chrome.SodaRecognitionResult recognition_result = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.recognition_result_);
    }

    // optional .speech.soda.chrome.SodaEndpointEvent endpoint_event = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.endpoint_event_);
    }

    // optional .speech.soda.chrome.SodaAudioLevelInfo audio_level_info = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.audio_level_info_);
    }

    // optional .speech.soda.chrome.SodaLangIdEvent langid_event = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.langid_event_);
    }

    // optional .speech.soda.chrome.SodaResponse.SodaMessageType soda_type = 1 [default = UNKNOWN];
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_soda_type());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SodaResponse::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const SodaResponse*>(
      &from));
}

void SodaResponse::MergeFrom(const SodaResponse& from) {
  SodaResponse* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:speech.soda.chrome.SodaResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.log_lines_.MergeFrom(from._impl_.log_lines_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_recognition_result()->::speech::soda::chrome::SodaRecognitionResult::MergeFrom(
          from._internal_recognition_result());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_endpoint_event()->::speech::soda::chrome::SodaEndpointEvent::MergeFrom(
          from._internal_endpoint_event());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_audio_level_info()->::speech::soda::chrome::SodaAudioLevelInfo::MergeFrom(
          from._internal_audio_level_info());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_langid_event()->::speech::soda::chrome::SodaLangIdEvent::MergeFrom(
          from._internal_langid_event());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.soda_type_ = from._impl_.soda_type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SodaResponse::CopyFrom(const SodaResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:speech.soda.chrome.SodaResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SodaResponse::IsInitialized() const {
  return true;
}

void SodaResponse::InternalSwap(SodaResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.log_lines_.InternalSwap(&other->_impl_.log_lines_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SodaResponse, _impl_.soda_type_)
      + sizeof(SodaResponse::_impl_.soda_type_)
      - PROTOBUF_FIELD_OFFSET(SodaResponse, _impl_.recognition_result_)>(
          reinterpret_cast<char*>(&_impl_.recognition_result_),
          reinterpret_cast<char*>(&other->_impl_.recognition_result_));
}

std::string SodaResponse::GetTypeName() const {
  return "speech.soda.chrome.SodaResponse";
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace chrome
}  // namespace soda
}  // namespace speech
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::speech::soda::chrome::ExtendedSodaConfigMsg*
Arena::CreateMaybeMessage< ::speech::soda::chrome::ExtendedSodaConfigMsg >(Arena* arena) {
  return Arena::CreateMessageInternal< ::speech::soda::chrome::ExtendedSodaConfigMsg >(arena);
}
template<> PROTOBUF_NOINLINE ::speech::soda::chrome::MultilangConfig_MultilangLanguagePackDirectoryEntry_DoNotUse*
Arena::CreateMaybeMessage< ::speech::soda::chrome::MultilangConfig_MultilangLanguagePackDirectoryEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::speech::soda::chrome::MultilangConfig_MultilangLanguagePackDirectoryEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::speech::soda::chrome::MultilangConfig*
Arena::CreateMaybeMessage< ::speech::soda::chrome::MultilangConfig >(Arena* arena) {
  return Arena::CreateMessageInternal< ::speech::soda::chrome::MultilangConfig >(arena);
}
template<> PROTOBUF_NOINLINE ::speech::soda::chrome::TimingMetrics*
Arena::CreateMaybeMessage< ::speech::soda::chrome::TimingMetrics >(Arena* arena) {
  return Arena::CreateMessageInternal< ::speech::soda::chrome::TimingMetrics >(arena);
}
template<> PROTOBUF_NOINLINE ::speech::soda::chrome::HypothesisPart*
Arena::CreateMaybeMessage< ::speech::soda::chrome::HypothesisPart >(Arena* arena) {
  return Arena::CreateMessageInternal< ::speech::soda::chrome::HypothesisPart >(arena);
}
template<> PROTOBUF_NOINLINE ::speech::soda::chrome::SodaRecognitionResult*
Arena::CreateMaybeMessage< ::speech::soda::chrome::SodaRecognitionResult >(Arena* arena) {
  return Arena::CreateMessageInternal< ::speech::soda::chrome::SodaRecognitionResult >(arena);
}
template<> PROTOBUF_NOINLINE ::speech::soda::chrome::SodaEndpointEvent*
Arena::CreateMaybeMessage< ::speech::soda::chrome::SodaEndpointEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::speech::soda::chrome::SodaEndpointEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::speech::soda::chrome::SodaAudioLevelInfo*
Arena::CreateMaybeMessage< ::speech::soda::chrome::SodaAudioLevelInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::speech::soda::chrome::SodaAudioLevelInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::speech::soda::chrome::SodaLangIdEvent*
Arena::CreateMaybeMessage< ::speech::soda::chrome::SodaLangIdEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::speech::soda::chrome::SodaLangIdEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::speech::soda::chrome::SodaResponse*
Arena::CreateMaybeMessage< ::speech::soda::chrome::SodaResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::speech::soda::chrome::SodaResponse >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
