// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: soda_api.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_soda_5fapi_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_soda_5fapi_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry_lite.h>
#include <google/protobuf/map_field_lite.h>
#include <google/protobuf/generated_enum_util.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_soda_5fapi_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_soda_5fapi_2eproto {
  static const uint32_t offsets[];
};
namespace speech {
namespace soda {
namespace chrome {
class ExtendedSodaConfigMsg;
struct ExtendedSodaConfigMsgDefaultTypeInternal;
extern ExtendedSodaConfigMsgDefaultTypeInternal _ExtendedSodaConfigMsg_default_instance_;
class HypothesisPart;
struct HypothesisPartDefaultTypeInternal;
extern HypothesisPartDefaultTypeInternal _HypothesisPart_default_instance_;
class MultilangConfig;
struct MultilangConfigDefaultTypeInternal;
extern MultilangConfigDefaultTypeInternal _MultilangConfig_default_instance_;
class MultilangConfig_MultilangLanguagePackDirectoryEntry_DoNotUse;
struct MultilangConfig_MultilangLanguagePackDirectoryEntry_DoNotUseDefaultTypeInternal;
extern MultilangConfig_MultilangLanguagePackDirectoryEntry_DoNotUseDefaultTypeInternal _MultilangConfig_MultilangLanguagePackDirectoryEntry_DoNotUse_default_instance_;
class SodaAudioLevelInfo;
struct SodaAudioLevelInfoDefaultTypeInternal;
extern SodaAudioLevelInfoDefaultTypeInternal _SodaAudioLevelInfo_default_instance_;
class SodaEndpointEvent;
struct SodaEndpointEventDefaultTypeInternal;
extern SodaEndpointEventDefaultTypeInternal _SodaEndpointEvent_default_instance_;
class SodaLangIdEvent;
struct SodaLangIdEventDefaultTypeInternal;
extern SodaLangIdEventDefaultTypeInternal _SodaLangIdEvent_default_instance_;
class SodaRecognitionResult;
struct SodaRecognitionResultDefaultTypeInternal;
extern SodaRecognitionResultDefaultTypeInternal _SodaRecognitionResult_default_instance_;
class SodaResponse;
struct SodaResponseDefaultTypeInternal;
extern SodaResponseDefaultTypeInternal _SodaResponse_default_instance_;
class TimingMetrics;
struct TimingMetricsDefaultTypeInternal;
extern TimingMetricsDefaultTypeInternal _TimingMetrics_default_instance_;
}  // namespace chrome
}  // namespace soda
}  // namespace speech
PROTOBUF_NAMESPACE_OPEN
template<> ::speech::soda::chrome::ExtendedSodaConfigMsg* Arena::CreateMaybeMessage<::speech::soda::chrome::ExtendedSodaConfigMsg>(Arena*);
template<> ::speech::soda::chrome::HypothesisPart* Arena::CreateMaybeMessage<::speech::soda::chrome::HypothesisPart>(Arena*);
template<> ::speech::soda::chrome::MultilangConfig* Arena::CreateMaybeMessage<::speech::soda::chrome::MultilangConfig>(Arena*);
template<> ::speech::soda::chrome::MultilangConfig_MultilangLanguagePackDirectoryEntry_DoNotUse* Arena::CreateMaybeMessage<::speech::soda::chrome::MultilangConfig_MultilangLanguagePackDirectoryEntry_DoNotUse>(Arena*);
template<> ::speech::soda::chrome::SodaAudioLevelInfo* Arena::CreateMaybeMessage<::speech::soda::chrome::SodaAudioLevelInfo>(Arena*);
template<> ::speech::soda::chrome::SodaEndpointEvent* Arena::CreateMaybeMessage<::speech::soda::chrome::SodaEndpointEvent>(Arena*);
template<> ::speech::soda::chrome::SodaLangIdEvent* Arena::CreateMaybeMessage<::speech::soda::chrome::SodaLangIdEvent>(Arena*);
template<> ::speech::soda::chrome::SodaRecognitionResult* Arena::CreateMaybeMessage<::speech::soda::chrome::SodaRecognitionResult>(Arena*);
template<> ::speech::soda::chrome::SodaResponse* Arena::CreateMaybeMessage<::speech::soda::chrome::SodaResponse>(Arena*);
template<> ::speech::soda::chrome::TimingMetrics* Arena::CreateMaybeMessage<::speech::soda::chrome::TimingMetrics>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace speech {
namespace soda {
namespace chrome {

enum ExtendedSodaConfigMsg_RecognitionMode : int {
  ExtendedSodaConfigMsg_RecognitionMode_UNKNOWN = 0,
  ExtendedSodaConfigMsg_RecognitionMode_IME = 1,
  ExtendedSodaConfigMsg_RecognitionMode_CAPTION = 2
};
bool ExtendedSodaConfigMsg_RecognitionMode_IsValid(int value);
constexpr ExtendedSodaConfigMsg_RecognitionMode ExtendedSodaConfigMsg_RecognitionMode_RecognitionMode_MIN = ExtendedSodaConfigMsg_RecognitionMode_UNKNOWN;
constexpr ExtendedSodaConfigMsg_RecognitionMode ExtendedSodaConfigMsg_RecognitionMode_RecognitionMode_MAX = ExtendedSodaConfigMsg_RecognitionMode_CAPTION;
constexpr int ExtendedSodaConfigMsg_RecognitionMode_RecognitionMode_ARRAYSIZE = ExtendedSodaConfigMsg_RecognitionMode_RecognitionMode_MAX + 1;

const std::string& ExtendedSodaConfigMsg_RecognitionMode_Name(ExtendedSodaConfigMsg_RecognitionMode value);
template<typename T>
inline const std::string& ExtendedSodaConfigMsg_RecognitionMode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ExtendedSodaConfigMsg_RecognitionMode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ExtendedSodaConfigMsg_RecognitionMode_Name.");
  return ExtendedSodaConfigMsg_RecognitionMode_Name(static_cast<ExtendedSodaConfigMsg_RecognitionMode>(enum_t_value));
}
bool ExtendedSodaConfigMsg_RecognitionMode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ExtendedSodaConfigMsg_RecognitionMode* value);
enum SodaRecognitionResult_ResultType : int {
  SodaRecognitionResult_ResultType_UNKNOWN = 0,
  SodaRecognitionResult_ResultType_PARTIAL = 1,
  SodaRecognitionResult_ResultType_FINAL = 2,
  SodaRecognitionResult_ResultType_PREFETCH = 3
};
bool SodaRecognitionResult_ResultType_IsValid(int value);
constexpr SodaRecognitionResult_ResultType SodaRecognitionResult_ResultType_ResultType_MIN = SodaRecognitionResult_ResultType_UNKNOWN;
constexpr SodaRecognitionResult_ResultType SodaRecognitionResult_ResultType_ResultType_MAX = SodaRecognitionResult_ResultType_PREFETCH;
constexpr int SodaRecognitionResult_ResultType_ResultType_ARRAYSIZE = SodaRecognitionResult_ResultType_ResultType_MAX + 1;

const std::string& SodaRecognitionResult_ResultType_Name(SodaRecognitionResult_ResultType value);
template<typename T>
inline const std::string& SodaRecognitionResult_ResultType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SodaRecognitionResult_ResultType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SodaRecognitionResult_ResultType_Name.");
  return SodaRecognitionResult_ResultType_Name(static_cast<SodaRecognitionResult_ResultType>(enum_t_value));
}
bool SodaRecognitionResult_ResultType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SodaRecognitionResult_ResultType* value);
enum SodaRecognitionResult_FinalResultEndpointReason : int {
  SodaRecognitionResult_FinalResultEndpointReason_ENDPOINT_UNKNOWN = 0,
  SodaRecognitionResult_FinalResultEndpointReason_ENDPOINT_END_OF_SPEECH = 1,
  SodaRecognitionResult_FinalResultEndpointReason_ENDPOINT_END_OF_UTTERANCE = 2,
  SodaRecognitionResult_FinalResultEndpointReason_ENDPOINT_END_OF_AUDIO = 3,
  SodaRecognitionResult_FinalResultEndpointReason_ENDPOINT_ASR_RESET_BY_HOTWORD = 4,
  SodaRecognitionResult_FinalResultEndpointReason_ENDPOINT_ASR_RESET_EXTERNAL = 5,
  SodaRecognitionResult_FinalResultEndpointReason_ENDPOINT_ASR_ERROR = 6
};
bool SodaRecognitionResult_FinalResultEndpointReason_IsValid(int value);
constexpr SodaRecognitionResult_FinalResultEndpointReason SodaRecognitionResult_FinalResultEndpointReason_FinalResultEndpointReason_MIN = SodaRecognitionResult_FinalResultEndpointReason_ENDPOINT_UNKNOWN;
constexpr SodaRecognitionResult_FinalResultEndpointReason SodaRecognitionResult_FinalResultEndpointReason_FinalResultEndpointReason_MAX = SodaRecognitionResult_FinalResultEndpointReason_ENDPOINT_ASR_ERROR;
constexpr int SodaRecognitionResult_FinalResultEndpointReason_FinalResultEndpointReason_ARRAYSIZE = SodaRecognitionResult_FinalResultEndpointReason_FinalResultEndpointReason_MAX + 1;

const std::string& SodaRecognitionResult_FinalResultEndpointReason_Name(SodaRecognitionResult_FinalResultEndpointReason value);
template<typename T>
inline const std::string& SodaRecognitionResult_FinalResultEndpointReason_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SodaRecognitionResult_FinalResultEndpointReason>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SodaRecognitionResult_FinalResultEndpointReason_Name.");
  return SodaRecognitionResult_FinalResultEndpointReason_Name(static_cast<SodaRecognitionResult_FinalResultEndpointReason>(enum_t_value));
}
bool SodaRecognitionResult_FinalResultEndpointReason_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SodaRecognitionResult_FinalResultEndpointReason* value);
enum SodaEndpointEvent_EndpointType : int {
  SodaEndpointEvent_EndpointType_START_OF_SPEECH = 0,
  SodaEndpointEvent_EndpointType_END_OF_SPEECH = 1,
  SodaEndpointEvent_EndpointType_END_OF_AUDIO = 2,
  SodaEndpointEvent_EndpointType_END_OF_UTTERANCE = 3,
  SodaEndpointEvent_EndpointType_UNKNOWN = 4
};
bool SodaEndpointEvent_EndpointType_IsValid(int value);
constexpr SodaEndpointEvent_EndpointType SodaEndpointEvent_EndpointType_EndpointType_MIN = SodaEndpointEvent_EndpointType_START_OF_SPEECH;
constexpr SodaEndpointEvent_EndpointType SodaEndpointEvent_EndpointType_EndpointType_MAX = SodaEndpointEvent_EndpointType_UNKNOWN;
constexpr int SodaEndpointEvent_EndpointType_EndpointType_ARRAYSIZE = SodaEndpointEvent_EndpointType_EndpointType_MAX + 1;

const std::string& SodaEndpointEvent_EndpointType_Name(SodaEndpointEvent_EndpointType value);
template<typename T>
inline const std::string& SodaEndpointEvent_EndpointType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SodaEndpointEvent_EndpointType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SodaEndpointEvent_EndpointType_Name.");
  return SodaEndpointEvent_EndpointType_Name(static_cast<SodaEndpointEvent_EndpointType>(enum_t_value));
}
bool SodaEndpointEvent_EndpointType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SodaEndpointEvent_EndpointType* value);
enum SodaResponse_SodaMessageType : int {
  SodaResponse_SodaMessageType_UNKNOWN = 0,
  SodaResponse_SodaMessageType_RECOGNITION = 1,
  SodaResponse_SodaMessageType_STOP = 2,
  SodaResponse_SodaMessageType_SHUTDOWN = 3,
  SodaResponse_SodaMessageType_START = 4,
  SodaResponse_SodaMessageType_ENDPOINT = 5,
  SodaResponse_SodaMessageType_AUDIO_LEVEL = 6,
  SodaResponse_SodaMessageType_LANGID = 7,
  SodaResponse_SodaMessageType_LOGS_ONLY_ARTIFICIAL_MESSAGE = 8
};
bool SodaResponse_SodaMessageType_IsValid(int value);
constexpr SodaResponse_SodaMessageType SodaResponse_SodaMessageType_SodaMessageType_MIN = SodaResponse_SodaMessageType_UNKNOWN;
constexpr SodaResponse_SodaMessageType SodaResponse_SodaMessageType_SodaMessageType_MAX = SodaResponse_SodaMessageType_LOGS_ONLY_ARTIFICIAL_MESSAGE;
constexpr int SodaResponse_SodaMessageType_SodaMessageType_ARRAYSIZE = SodaResponse_SodaMessageType_SodaMessageType_MAX + 1;

const std::string& SodaResponse_SodaMessageType_Name(SodaResponse_SodaMessageType value);
template<typename T>
inline const std::string& SodaResponse_SodaMessageType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SodaResponse_SodaMessageType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SodaResponse_SodaMessageType_Name.");
  return SodaResponse_SodaMessageType_Name(static_cast<SodaResponse_SodaMessageType>(enum_t_value));
}
bool SodaResponse_SodaMessageType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SodaResponse_SodaMessageType* value);
// ===================================================================

class ExtendedSodaConfigMsg final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:speech.soda.chrome.ExtendedSodaConfigMsg) */ {
 public:
  inline ExtendedSodaConfigMsg() : ExtendedSodaConfigMsg(nullptr) {}
  ~ExtendedSodaConfigMsg() override;
  explicit PROTOBUF_CONSTEXPR ExtendedSodaConfigMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ExtendedSodaConfigMsg(const ExtendedSodaConfigMsg& from);
  ExtendedSodaConfigMsg(ExtendedSodaConfigMsg&& from) noexcept
    : ExtendedSodaConfigMsg() {
    *this = ::std::move(from);
  }

  inline ExtendedSodaConfigMsg& operator=(const ExtendedSodaConfigMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExtendedSodaConfigMsg& operator=(ExtendedSodaConfigMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ExtendedSodaConfigMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExtendedSodaConfigMsg* internal_default_instance() {
    return reinterpret_cast<const ExtendedSodaConfigMsg*>(
               &_ExtendedSodaConfigMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(ExtendedSodaConfigMsg& a, ExtendedSodaConfigMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(ExtendedSodaConfigMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExtendedSodaConfigMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExtendedSodaConfigMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ExtendedSodaConfigMsg>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ExtendedSodaConfigMsg& from);
  void MergeFrom(const ExtendedSodaConfigMsg& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ExtendedSodaConfigMsg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "speech.soda.chrome.ExtendedSodaConfigMsg";
  }
  protected:
  explicit ExtendedSodaConfigMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef ExtendedSodaConfigMsg_RecognitionMode RecognitionMode;
  static constexpr RecognitionMode UNKNOWN =
    ExtendedSodaConfigMsg_RecognitionMode_UNKNOWN;
  static constexpr RecognitionMode IME =
    ExtendedSodaConfigMsg_RecognitionMode_IME;
  static constexpr RecognitionMode CAPTION =
    ExtendedSodaConfigMsg_RecognitionMode_CAPTION;
  static inline bool RecognitionMode_IsValid(int value) {
    return ExtendedSodaConfigMsg_RecognitionMode_IsValid(value);
  }
  static constexpr RecognitionMode RecognitionMode_MIN =
    ExtendedSodaConfigMsg_RecognitionMode_RecognitionMode_MIN;
  static constexpr RecognitionMode RecognitionMode_MAX =
    ExtendedSodaConfigMsg_RecognitionMode_RecognitionMode_MAX;
  static constexpr int RecognitionMode_ARRAYSIZE =
    ExtendedSodaConfigMsg_RecognitionMode_RecognitionMode_ARRAYSIZE;
  template<typename T>
  static inline const std::string& RecognitionMode_Name(T enum_t_value) {
    static_assert(::std::is_same<T, RecognitionMode>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function RecognitionMode_Name.");
    return ExtendedSodaConfigMsg_RecognitionMode_Name(enum_t_value);
  }
  static inline bool RecognitionMode_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      RecognitionMode* value) {
    return ExtendedSodaConfigMsg_RecognitionMode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kConfigFileLocationFieldNumber = 3,
    kApiKeyFieldNumber = 6,
    kLanguagePackDirectoryFieldNumber = 7,
    kMultilangConfigFieldNumber = 15,
    kChannelCountFieldNumber = 1,
    kSampleRateFieldNumber = 2,
    kMaxBufferBytesFieldNumber = 4,
    kSimulateRealtimeTestonlyFieldNumber = 5,
    kEnableLangIdFieldNumber = 11,
    kEnableSpeakerChangeDetectionFieldNumber = 13,
    kIncludeLoggingFieldNumber = 14,
    kRecognitionModeFieldNumber = 8,
    kResetOnFinalResultFieldNumber = 9,
    kIncludeTimingMetricsFieldNumber = 10,
    kEnableFormattingFieldNumber = 12,
  };
  // optional string config_file_location = 3 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_config_file_location() const;
  private:
  bool _internal_has_config_file_location() const;
  public:
  PROTOBUF_DEPRECATED void clear_config_file_location();
  PROTOBUF_DEPRECATED const std::string& config_file_location() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  PROTOBUF_DEPRECATED void set_config_file_location(ArgT0&& arg0, ArgT... args);
  PROTOBUF_DEPRECATED std::string* mutable_config_file_location();
  PROTOBUF_NODISCARD PROTOBUF_DEPRECATED std::string* release_config_file_location();
  PROTOBUF_DEPRECATED void set_allocated_config_file_location(std::string* config_file_location);
  private:
  const std::string& _internal_config_file_location() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_config_file_location(const std::string& value);
  std::string* _internal_mutable_config_file_location();
  public:

  // optional string api_key = 6;
  bool has_api_key() const;
  private:
  bool _internal_has_api_key() const;
  public:
  void clear_api_key();
  const std::string& api_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_api_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_api_key();
  PROTOBUF_NODISCARD std::string* release_api_key();
  void set_allocated_api_key(std::string* api_key);
  private:
  const std::string& _internal_api_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_api_key(const std::string& value);
  std::string* _internal_mutable_api_key();
  public:

  // optional string language_pack_directory = 7;
  bool has_language_pack_directory() const;
  private:
  bool _internal_has_language_pack_directory() const;
  public:
  void clear_language_pack_directory();
  const std::string& language_pack_directory() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_language_pack_directory(ArgT0&& arg0, ArgT... args);
  std::string* mutable_language_pack_directory();
  PROTOBUF_NODISCARD std::string* release_language_pack_directory();
  void set_allocated_language_pack_directory(std::string* language_pack_directory);
  private:
  const std::string& _internal_language_pack_directory() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_language_pack_directory(const std::string& value);
  std::string* _internal_mutable_language_pack_directory();
  public:

  // optional .speech.soda.chrome.MultilangConfig multilang_config = 15;
  bool has_multilang_config() const;
  private:
  bool _internal_has_multilang_config() const;
  public:
  void clear_multilang_config();
  const ::speech::soda::chrome::MultilangConfig& multilang_config() const;
  PROTOBUF_NODISCARD ::speech::soda::chrome::MultilangConfig* release_multilang_config();
  ::speech::soda::chrome::MultilangConfig* mutable_multilang_config();
  void set_allocated_multilang_config(::speech::soda::chrome::MultilangConfig* multilang_config);
  private:
  const ::speech::soda::chrome::MultilangConfig& _internal_multilang_config() const;
  ::speech::soda::chrome::MultilangConfig* _internal_mutable_multilang_config();
  public:
  void unsafe_arena_set_allocated_multilang_config(
      ::speech::soda::chrome::MultilangConfig* multilang_config);
  ::speech::soda::chrome::MultilangConfig* unsafe_arena_release_multilang_config();

  // optional int32 channel_count = 1;
  bool has_channel_count() const;
  private:
  bool _internal_has_channel_count() const;
  public:
  void clear_channel_count();
  int32_t channel_count() const;
  void set_channel_count(int32_t value);
  private:
  int32_t _internal_channel_count() const;
  void _internal_set_channel_count(int32_t value);
  public:

  // optional int32 sample_rate = 2;
  bool has_sample_rate() const;
  private:
  bool _internal_has_sample_rate() const;
  public:
  void clear_sample_rate();
  int32_t sample_rate() const;
  void set_sample_rate(int32_t value);
  private:
  int32_t _internal_sample_rate() const;
  void _internal_set_sample_rate(int32_t value);
  public:

  // optional int32 max_buffer_bytes = 4 [default = 0];
  bool has_max_buffer_bytes() const;
  private:
  bool _internal_has_max_buffer_bytes() const;
  public:
  void clear_max_buffer_bytes();
  int32_t max_buffer_bytes() const;
  void set_max_buffer_bytes(int32_t value);
  private:
  int32_t _internal_max_buffer_bytes() const;
  void _internal_set_max_buffer_bytes(int32_t value);
  public:

  // optional bool simulate_realtime_testonly = 5 [default = false];
  bool has_simulate_realtime_testonly() const;
  private:
  bool _internal_has_simulate_realtime_testonly() const;
  public:
  void clear_simulate_realtime_testonly();
  bool simulate_realtime_testonly() const;
  void set_simulate_realtime_testonly(bool value);
  private:
  bool _internal_simulate_realtime_testonly() const;
  void _internal_set_simulate_realtime_testonly(bool value);
  public:

  // optional bool enable_lang_id = 11 [default = false];
  bool has_enable_lang_id() const;
  private:
  bool _internal_has_enable_lang_id() const;
  public:
  void clear_enable_lang_id();
  bool enable_lang_id() const;
  void set_enable_lang_id(bool value);
  private:
  bool _internal_enable_lang_id() const;
  void _internal_set_enable_lang_id(bool value);
  public:

  // optional bool enable_speaker_change_detection = 13 [default = false];
  bool has_enable_speaker_change_detection() const;
  private:
  bool _internal_has_enable_speaker_change_detection() const;
  public:
  void clear_enable_speaker_change_detection();
  bool enable_speaker_change_detection() const;
  void set_enable_speaker_change_detection(bool value);
  private:
  bool _internal_enable_speaker_change_detection() const;
  void _internal_set_enable_speaker_change_detection(bool value);
  public:

  // optional bool include_logging = 14 [default = false];
  bool has_include_logging() const;
  private:
  bool _internal_has_include_logging() const;
  public:
  void clear_include_logging();
  bool include_logging() const;
  void set_include_logging(bool value);
  private:
  bool _internal_include_logging() const;
  void _internal_set_include_logging(bool value);
  public:

  // optional .speech.soda.chrome.ExtendedSodaConfigMsg.RecognitionMode recognition_mode = 8 [default = IME];
  bool has_recognition_mode() const;
  private:
  bool _internal_has_recognition_mode() const;
  public:
  void clear_recognition_mode();
  ::speech::soda::chrome::ExtendedSodaConfigMsg_RecognitionMode recognition_mode() const;
  void set_recognition_mode(::speech::soda::chrome::ExtendedSodaConfigMsg_RecognitionMode value);
  private:
  ::speech::soda::chrome::ExtendedSodaConfigMsg_RecognitionMode _internal_recognition_mode() const;
  void _internal_set_recognition_mode(::speech::soda::chrome::ExtendedSodaConfigMsg_RecognitionMode value);
  public:

  // optional bool reset_on_final_result = 9 [default = true, deprecated = true];
  PROTOBUF_DEPRECATED bool has_reset_on_final_result() const;
  private:
  bool _internal_has_reset_on_final_result() const;
  public:
  PROTOBUF_DEPRECATED void clear_reset_on_final_result();
  PROTOBUF_DEPRECATED bool reset_on_final_result() const;
  PROTOBUF_DEPRECATED void set_reset_on_final_result(bool value);
  private:
  bool _internal_reset_on_final_result() const;
  void _internal_set_reset_on_final_result(bool value);
  public:

  // optional bool include_timing_metrics = 10 [default = true];
  bool has_include_timing_metrics() const;
  private:
  bool _internal_has_include_timing_metrics() const;
  public:
  void clear_include_timing_metrics();
  bool include_timing_metrics() const;
  void set_include_timing_metrics(bool value);
  private:
  bool _internal_include_timing_metrics() const;
  void _internal_set_include_timing_metrics(bool value);
  public:

  // optional bool enable_formatting = 12 [default = true];
  bool has_enable_formatting() const;
  private:
  bool _internal_has_enable_formatting() const;
  public:
  void clear_enable_formatting();
  bool enable_formatting() const;
  void set_enable_formatting(bool value);
  private:
  bool _internal_enable_formatting() const;
  void _internal_set_enable_formatting(bool value);
  public:

  // @@protoc_insertion_point(class_scope:speech.soda.chrome.ExtendedSodaConfigMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr config_file_location_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr api_key_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr language_pack_directory_;
    ::speech::soda::chrome::MultilangConfig* multilang_config_;
    int32_t channel_count_;
    int32_t sample_rate_;
    int32_t max_buffer_bytes_;
    bool simulate_realtime_testonly_;
    bool enable_lang_id_;
    bool enable_speaker_change_detection_;
    bool include_logging_;
    int recognition_mode_;
    bool reset_on_final_result_;
    bool include_timing_metrics_;
    bool enable_formatting_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_soda_5fapi_2eproto;
};
// -------------------------------------------------------------------

class MultilangConfig_MultilangLanguagePackDirectoryEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntryLite<MultilangConfig_MultilangLanguagePackDirectoryEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntryLite<MultilangConfig_MultilangLanguagePackDirectoryEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  MultilangConfig_MultilangLanguagePackDirectoryEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR MultilangConfig_MultilangLanguagePackDirectoryEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit MultilangConfig_MultilangLanguagePackDirectoryEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const MultilangConfig_MultilangLanguagePackDirectoryEntry_DoNotUse& other);
  static const MultilangConfig_MultilangLanguagePackDirectoryEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const MultilangConfig_MultilangLanguagePackDirectoryEntry_DoNotUse*>(&_MultilangConfig_MultilangLanguagePackDirectoryEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(void*) { return true; }
  static bool ValidateValue(void*) { return true; }
  friend struct ::TableStruct_soda_5fapi_2eproto;
};

// -------------------------------------------------------------------

class MultilangConfig final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:speech.soda.chrome.MultilangConfig) */ {
 public:
  inline MultilangConfig() : MultilangConfig(nullptr) {}
  ~MultilangConfig() override;
  explicit PROTOBUF_CONSTEXPR MultilangConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MultilangConfig(const MultilangConfig& from);
  MultilangConfig(MultilangConfig&& from) noexcept
    : MultilangConfig() {
    *this = ::std::move(from);
  }

  inline MultilangConfig& operator=(const MultilangConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline MultilangConfig& operator=(MultilangConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const MultilangConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const MultilangConfig* internal_default_instance() {
    return reinterpret_cast<const MultilangConfig*>(
               &_MultilangConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(MultilangConfig& a, MultilangConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(MultilangConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MultilangConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MultilangConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MultilangConfig>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const MultilangConfig& from);
  void MergeFrom(const MultilangConfig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(MultilangConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "speech.soda.chrome.MultilangConfig";
  }
  protected:
  explicit MultilangConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kMultilangLanguagePackDirectoryFieldNumber = 1,
    kRewindWhenSwitchingLanguageFieldNumber = 2,
  };
  // map<string, string> multilang_language_pack_directory = 1;
  int multilang_language_pack_directory_size() const;
  private:
  int _internal_multilang_language_pack_directory_size() const;
  public:
  void clear_multilang_language_pack_directory();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_multilang_language_pack_directory() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_multilang_language_pack_directory();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      multilang_language_pack_directory() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_multilang_language_pack_directory();

  // optional bool rewind_when_switching_language = 2;
  bool has_rewind_when_switching_language() const;
  private:
  bool _internal_has_rewind_when_switching_language() const;
  public:
  void clear_rewind_when_switching_language();
  bool rewind_when_switching_language() const;
  void set_rewind_when_switching_language(bool value);
  private:
  bool _internal_rewind_when_switching_language() const;
  void _internal_set_rewind_when_switching_language(bool value);
  public:

  // @@protoc_insertion_point(class_scope:speech.soda.chrome.MultilangConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapFieldLite<
        MultilangConfig_MultilangLanguagePackDirectoryEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> multilang_language_pack_directory_;
    bool rewind_when_switching_language_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_soda_5fapi_2eproto;
};
// -------------------------------------------------------------------

class TimingMetrics final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:speech.soda.chrome.TimingMetrics) */ {
 public:
  inline TimingMetrics() : TimingMetrics(nullptr) {}
  ~TimingMetrics() override;
  explicit PROTOBUF_CONSTEXPR TimingMetrics(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TimingMetrics(const TimingMetrics& from);
  TimingMetrics(TimingMetrics&& from) noexcept
    : TimingMetrics() {
    *this = ::std::move(from);
  }

  inline TimingMetrics& operator=(const TimingMetrics& from) {
    CopyFrom(from);
    return *this;
  }
  inline TimingMetrics& operator=(TimingMetrics&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const TimingMetrics& default_instance() {
    return *internal_default_instance();
  }
  static inline const TimingMetrics* internal_default_instance() {
    return reinterpret_cast<const TimingMetrics*>(
               &_TimingMetrics_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(TimingMetrics& a, TimingMetrics& b) {
    a.Swap(&b);
  }
  inline void Swap(TimingMetrics* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TimingMetrics* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TimingMetrics* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TimingMetrics>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const TimingMetrics& from);
  void MergeFrom(const TimingMetrics& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TimingMetrics* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "speech.soda.chrome.TimingMetrics";
  }
  protected:
  explicit TimingMetrics(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAudioStartEpochUsecFieldNumber = 1,
    kAudioStartTimeUsecFieldNumber = 2,
    kElapsedWallTimeUsecFieldNumber = 3,
    kEventEndTimeUsecFieldNumber = 4,
  };
  // optional int64 audio_start_epoch_usec = 1;
  bool has_audio_start_epoch_usec() const;
  private:
  bool _internal_has_audio_start_epoch_usec() const;
  public:
  void clear_audio_start_epoch_usec();
  int64_t audio_start_epoch_usec() const;
  void set_audio_start_epoch_usec(int64_t value);
  private:
  int64_t _internal_audio_start_epoch_usec() const;
  void _internal_set_audio_start_epoch_usec(int64_t value);
  public:

  // optional int64 audio_start_time_usec = 2;
  bool has_audio_start_time_usec() const;
  private:
  bool _internal_has_audio_start_time_usec() const;
  public:
  void clear_audio_start_time_usec();
  int64_t audio_start_time_usec() const;
  void set_audio_start_time_usec(int64_t value);
  private:
  int64_t _internal_audio_start_time_usec() const;
  void _internal_set_audio_start_time_usec(int64_t value);
  public:

  // optional int64 elapsed_wall_time_usec = 3;
  bool has_elapsed_wall_time_usec() const;
  private:
  bool _internal_has_elapsed_wall_time_usec() const;
  public:
  void clear_elapsed_wall_time_usec();
  int64_t elapsed_wall_time_usec() const;
  void set_elapsed_wall_time_usec(int64_t value);
  private:
  int64_t _internal_elapsed_wall_time_usec() const;
  void _internal_set_elapsed_wall_time_usec(int64_t value);
  public:

  // optional int64 event_end_time_usec = 4;
  bool has_event_end_time_usec() const;
  private:
  bool _internal_has_event_end_time_usec() const;
  public:
  void clear_event_end_time_usec();
  int64_t event_end_time_usec() const;
  void set_event_end_time_usec(int64_t value);
  private:
  int64_t _internal_event_end_time_usec() const;
  void _internal_set_event_end_time_usec(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:speech.soda.chrome.TimingMetrics)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int64_t audio_start_epoch_usec_;
    int64_t audio_start_time_usec_;
    int64_t elapsed_wall_time_usec_;
    int64_t event_end_time_usec_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_soda_5fapi_2eproto;
};
// -------------------------------------------------------------------

class HypothesisPart final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:speech.soda.chrome.HypothesisPart) */ {
 public:
  inline HypothesisPart() : HypothesisPart(nullptr) {}
  ~HypothesisPart() override;
  explicit PROTOBUF_CONSTEXPR HypothesisPart(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HypothesisPart(const HypothesisPart& from);
  HypothesisPart(HypothesisPart&& from) noexcept
    : HypothesisPart() {
    *this = ::std::move(from);
  }

  inline HypothesisPart& operator=(const HypothesisPart& from) {
    CopyFrom(from);
    return *this;
  }
  inline HypothesisPart& operator=(HypothesisPart&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const HypothesisPart& default_instance() {
    return *internal_default_instance();
  }
  static inline const HypothesisPart* internal_default_instance() {
    return reinterpret_cast<const HypothesisPart*>(
               &_HypothesisPart_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(HypothesisPart& a, HypothesisPart& b) {
    a.Swap(&b);
  }
  inline void Swap(HypothesisPart* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HypothesisPart* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HypothesisPart* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HypothesisPart>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const HypothesisPart& from);
  void MergeFrom(const HypothesisPart& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(HypothesisPart* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "speech.soda.chrome.HypothesisPart";
  }
  protected:
  explicit HypothesisPart(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTextFieldNumber = 1,
    kAlignmentMsFieldNumber = 2,
  };
  // repeated string text = 1;
  int text_size() const;
  private:
  int _internal_text_size() const;
  public:
  void clear_text();
  const std::string& text(int index) const;
  std::string* mutable_text(int index);
  void set_text(int index, const std::string& value);
  void set_text(int index, std::string&& value);
  void set_text(int index, const char* value);
  void set_text(int index, const char* value, size_t size);
  std::string* add_text();
  void add_text(const std::string& value);
  void add_text(std::string&& value);
  void add_text(const char* value);
  void add_text(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& text() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_text();
  private:
  const std::string& _internal_text(int index) const;
  std::string* _internal_add_text();
  public:

  // optional int64 alignment_ms = 2;
  bool has_alignment_ms() const;
  private:
  bool _internal_has_alignment_ms() const;
  public:
  void clear_alignment_ms();
  int64_t alignment_ms() const;
  void set_alignment_ms(int64_t value);
  private:
  int64_t _internal_alignment_ms() const;
  void _internal_set_alignment_ms(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:speech.soda.chrome.HypothesisPart)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> text_;
    int64_t alignment_ms_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_soda_5fapi_2eproto;
};
// -------------------------------------------------------------------

class SodaRecognitionResult final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:speech.soda.chrome.SodaRecognitionResult) */ {
 public:
  inline SodaRecognitionResult() : SodaRecognitionResult(nullptr) {}
  ~SodaRecognitionResult() override;
  explicit PROTOBUF_CONSTEXPR SodaRecognitionResult(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SodaRecognitionResult(const SodaRecognitionResult& from);
  SodaRecognitionResult(SodaRecognitionResult&& from) noexcept
    : SodaRecognitionResult() {
    *this = ::std::move(from);
  }

  inline SodaRecognitionResult& operator=(const SodaRecognitionResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline SodaRecognitionResult& operator=(SodaRecognitionResult&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const SodaRecognitionResult& default_instance() {
    return *internal_default_instance();
  }
  static inline const SodaRecognitionResult* internal_default_instance() {
    return reinterpret_cast<const SodaRecognitionResult*>(
               &_SodaRecognitionResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(SodaRecognitionResult& a, SodaRecognitionResult& b) {
    a.Swap(&b);
  }
  inline void Swap(SodaRecognitionResult* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SodaRecognitionResult* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SodaRecognitionResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SodaRecognitionResult>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const SodaRecognitionResult& from);
  void MergeFrom(const SodaRecognitionResult& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SodaRecognitionResult* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "speech.soda.chrome.SodaRecognitionResult";
  }
  protected:
  explicit SodaRecognitionResult(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef SodaRecognitionResult_ResultType ResultType;
  static constexpr ResultType UNKNOWN =
    SodaRecognitionResult_ResultType_UNKNOWN;
  static constexpr ResultType PARTIAL =
    SodaRecognitionResult_ResultType_PARTIAL;
  static constexpr ResultType FINAL =
    SodaRecognitionResult_ResultType_FINAL;
  static constexpr ResultType PREFETCH =
    SodaRecognitionResult_ResultType_PREFETCH;
  static inline bool ResultType_IsValid(int value) {
    return SodaRecognitionResult_ResultType_IsValid(value);
  }
  static constexpr ResultType ResultType_MIN =
    SodaRecognitionResult_ResultType_ResultType_MIN;
  static constexpr ResultType ResultType_MAX =
    SodaRecognitionResult_ResultType_ResultType_MAX;
  static constexpr int ResultType_ARRAYSIZE =
    SodaRecognitionResult_ResultType_ResultType_ARRAYSIZE;
  template<typename T>
  static inline const std::string& ResultType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ResultType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ResultType_Name.");
    return SodaRecognitionResult_ResultType_Name(enum_t_value);
  }
  static inline bool ResultType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ResultType* value) {
    return SodaRecognitionResult_ResultType_Parse(name, value);
  }

  typedef SodaRecognitionResult_FinalResultEndpointReason FinalResultEndpointReason;
  static constexpr FinalResultEndpointReason ENDPOINT_UNKNOWN =
    SodaRecognitionResult_FinalResultEndpointReason_ENDPOINT_UNKNOWN;
  static constexpr FinalResultEndpointReason ENDPOINT_END_OF_SPEECH =
    SodaRecognitionResult_FinalResultEndpointReason_ENDPOINT_END_OF_SPEECH;
  static constexpr FinalResultEndpointReason ENDPOINT_END_OF_UTTERANCE =
    SodaRecognitionResult_FinalResultEndpointReason_ENDPOINT_END_OF_UTTERANCE;
  static constexpr FinalResultEndpointReason ENDPOINT_END_OF_AUDIO =
    SodaRecognitionResult_FinalResultEndpointReason_ENDPOINT_END_OF_AUDIO;
  static constexpr FinalResultEndpointReason ENDPOINT_ASR_RESET_BY_HOTWORD =
    SodaRecognitionResult_FinalResultEndpointReason_ENDPOINT_ASR_RESET_BY_HOTWORD;
  static constexpr FinalResultEndpointReason ENDPOINT_ASR_RESET_EXTERNAL =
    SodaRecognitionResult_FinalResultEndpointReason_ENDPOINT_ASR_RESET_EXTERNAL;
  static constexpr FinalResultEndpointReason ENDPOINT_ASR_ERROR =
    SodaRecognitionResult_FinalResultEndpointReason_ENDPOINT_ASR_ERROR;
  static inline bool FinalResultEndpointReason_IsValid(int value) {
    return SodaRecognitionResult_FinalResultEndpointReason_IsValid(value);
  }
  static constexpr FinalResultEndpointReason FinalResultEndpointReason_MIN =
    SodaRecognitionResult_FinalResultEndpointReason_FinalResultEndpointReason_MIN;
  static constexpr FinalResultEndpointReason FinalResultEndpointReason_MAX =
    SodaRecognitionResult_FinalResultEndpointReason_FinalResultEndpointReason_MAX;
  static constexpr int FinalResultEndpointReason_ARRAYSIZE =
    SodaRecognitionResult_FinalResultEndpointReason_FinalResultEndpointReason_ARRAYSIZE;
  template<typename T>
  static inline const std::string& FinalResultEndpointReason_Name(T enum_t_value) {
    static_assert(::std::is_same<T, FinalResultEndpointReason>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function FinalResultEndpointReason_Name.");
    return SodaRecognitionResult_FinalResultEndpointReason_Name(enum_t_value);
  }
  static inline bool FinalResultEndpointReason_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      FinalResultEndpointReason* value) {
    return SodaRecognitionResult_FinalResultEndpointReason_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kHypothesisFieldNumber = 1,
    kHypothesisPartFieldNumber = 5,
    kTimingMetricsFieldNumber = 4,
    kResultTypeFieldNumber = 2,
    kEndpointReasonFieldNumber = 3,
  };
  // repeated string hypothesis = 1;
  int hypothesis_size() const;
  private:
  int _internal_hypothesis_size() const;
  public:
  void clear_hypothesis();
  const std::string& hypothesis(int index) const;
  std::string* mutable_hypothesis(int index);
  void set_hypothesis(int index, const std::string& value);
  void set_hypothesis(int index, std::string&& value);
  void set_hypothesis(int index, const char* value);
  void set_hypothesis(int index, const char* value, size_t size);
  std::string* add_hypothesis();
  void add_hypothesis(const std::string& value);
  void add_hypothesis(std::string&& value);
  void add_hypothesis(const char* value);
  void add_hypothesis(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& hypothesis() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_hypothesis();
  private:
  const std::string& _internal_hypothesis(int index) const;
  std::string* _internal_add_hypothesis();
  public:

  // repeated .speech.soda.chrome.HypothesisPart hypothesis_part = 5;
  int hypothesis_part_size() const;
  private:
  int _internal_hypothesis_part_size() const;
  public:
  void clear_hypothesis_part();
  ::speech::soda::chrome::HypothesisPart* mutable_hypothesis_part(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::speech::soda::chrome::HypothesisPart >*
      mutable_hypothesis_part();
  private:
  const ::speech::soda::chrome::HypothesisPart& _internal_hypothesis_part(int index) const;
  ::speech::soda::chrome::HypothesisPart* _internal_add_hypothesis_part();
  public:
  const ::speech::soda::chrome::HypothesisPart& hypothesis_part(int index) const;
  ::speech::soda::chrome::HypothesisPart* add_hypothesis_part();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::speech::soda::chrome::HypothesisPart >&
      hypothesis_part() const;

  // optional .speech.soda.chrome.TimingMetrics timing_metrics = 4;
  bool has_timing_metrics() const;
  private:
  bool _internal_has_timing_metrics() const;
  public:
  void clear_timing_metrics();
  const ::speech::soda::chrome::TimingMetrics& timing_metrics() const;
  PROTOBUF_NODISCARD ::speech::soda::chrome::TimingMetrics* release_timing_metrics();
  ::speech::soda::chrome::TimingMetrics* mutable_timing_metrics();
  void set_allocated_timing_metrics(::speech::soda::chrome::TimingMetrics* timing_metrics);
  private:
  const ::speech::soda::chrome::TimingMetrics& _internal_timing_metrics() const;
  ::speech::soda::chrome::TimingMetrics* _internal_mutable_timing_metrics();
  public:
  void unsafe_arena_set_allocated_timing_metrics(
      ::speech::soda::chrome::TimingMetrics* timing_metrics);
  ::speech::soda::chrome::TimingMetrics* unsafe_arena_release_timing_metrics();

  // optional .speech.soda.chrome.SodaRecognitionResult.ResultType result_type = 2;
  bool has_result_type() const;
  private:
  bool _internal_has_result_type() const;
  public:
  void clear_result_type();
  ::speech::soda::chrome::SodaRecognitionResult_ResultType result_type() const;
  void set_result_type(::speech::soda::chrome::SodaRecognitionResult_ResultType value);
  private:
  ::speech::soda::chrome::SodaRecognitionResult_ResultType _internal_result_type() const;
  void _internal_set_result_type(::speech::soda::chrome::SodaRecognitionResult_ResultType value);
  public:

  // optional .speech.soda.chrome.SodaRecognitionResult.FinalResultEndpointReason endpoint_reason = 3;
  bool has_endpoint_reason() const;
  private:
  bool _internal_has_endpoint_reason() const;
  public:
  void clear_endpoint_reason();
  ::speech::soda::chrome::SodaRecognitionResult_FinalResultEndpointReason endpoint_reason() const;
  void set_endpoint_reason(::speech::soda::chrome::SodaRecognitionResult_FinalResultEndpointReason value);
  private:
  ::speech::soda::chrome::SodaRecognitionResult_FinalResultEndpointReason _internal_endpoint_reason() const;
  void _internal_set_endpoint_reason(::speech::soda::chrome::SodaRecognitionResult_FinalResultEndpointReason value);
  public:

  // @@protoc_insertion_point(class_scope:speech.soda.chrome.SodaRecognitionResult)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> hypothesis_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::speech::soda::chrome::HypothesisPart > hypothesis_part_;
    ::speech::soda::chrome::TimingMetrics* timing_metrics_;
    int result_type_;
    int endpoint_reason_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_soda_5fapi_2eproto;
};
// -------------------------------------------------------------------

class SodaEndpointEvent final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:speech.soda.chrome.SodaEndpointEvent) */ {
 public:
  inline SodaEndpointEvent() : SodaEndpointEvent(nullptr) {}
  ~SodaEndpointEvent() override;
  explicit PROTOBUF_CONSTEXPR SodaEndpointEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SodaEndpointEvent(const SodaEndpointEvent& from);
  SodaEndpointEvent(SodaEndpointEvent&& from) noexcept
    : SodaEndpointEvent() {
    *this = ::std::move(from);
  }

  inline SodaEndpointEvent& operator=(const SodaEndpointEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline SodaEndpointEvent& operator=(SodaEndpointEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const SodaEndpointEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const SodaEndpointEvent* internal_default_instance() {
    return reinterpret_cast<const SodaEndpointEvent*>(
               &_SodaEndpointEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(SodaEndpointEvent& a, SodaEndpointEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(SodaEndpointEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SodaEndpointEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SodaEndpointEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SodaEndpointEvent>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const SodaEndpointEvent& from);
  void MergeFrom(const SodaEndpointEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SodaEndpointEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "speech.soda.chrome.SodaEndpointEvent";
  }
  protected:
  explicit SodaEndpointEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef SodaEndpointEvent_EndpointType EndpointType;
  static constexpr EndpointType START_OF_SPEECH =
    SodaEndpointEvent_EndpointType_START_OF_SPEECH;
  static constexpr EndpointType END_OF_SPEECH =
    SodaEndpointEvent_EndpointType_END_OF_SPEECH;
  static constexpr EndpointType END_OF_AUDIO =
    SodaEndpointEvent_EndpointType_END_OF_AUDIO;
  static constexpr EndpointType END_OF_UTTERANCE =
    SodaEndpointEvent_EndpointType_END_OF_UTTERANCE;
  static constexpr EndpointType UNKNOWN =
    SodaEndpointEvent_EndpointType_UNKNOWN;
  static inline bool EndpointType_IsValid(int value) {
    return SodaEndpointEvent_EndpointType_IsValid(value);
  }
  static constexpr EndpointType EndpointType_MIN =
    SodaEndpointEvent_EndpointType_EndpointType_MIN;
  static constexpr EndpointType EndpointType_MAX =
    SodaEndpointEvent_EndpointType_EndpointType_MAX;
  static constexpr int EndpointType_ARRAYSIZE =
    SodaEndpointEvent_EndpointType_EndpointType_ARRAYSIZE;
  template<typename T>
  static inline const std::string& EndpointType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, EndpointType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function EndpointType_Name.");
    return SodaEndpointEvent_EndpointType_Name(enum_t_value);
  }
  static inline bool EndpointType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      EndpointType* value) {
    return SodaEndpointEvent_EndpointType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTimingMetricsFieldNumber = 2,
    kEndpointTypeFieldNumber = 1,
  };
  // optional .speech.soda.chrome.TimingMetrics timing_metrics = 2;
  bool has_timing_metrics() const;
  private:
  bool _internal_has_timing_metrics() const;
  public:
  void clear_timing_metrics();
  const ::speech::soda::chrome::TimingMetrics& timing_metrics() const;
  PROTOBUF_NODISCARD ::speech::soda::chrome::TimingMetrics* release_timing_metrics();
  ::speech::soda::chrome::TimingMetrics* mutable_timing_metrics();
  void set_allocated_timing_metrics(::speech::soda::chrome::TimingMetrics* timing_metrics);
  private:
  const ::speech::soda::chrome::TimingMetrics& _internal_timing_metrics() const;
  ::speech::soda::chrome::TimingMetrics* _internal_mutable_timing_metrics();
  public:
  void unsafe_arena_set_allocated_timing_metrics(
      ::speech::soda::chrome::TimingMetrics* timing_metrics);
  ::speech::soda::chrome::TimingMetrics* unsafe_arena_release_timing_metrics();

  // optional .speech.soda.chrome.SodaEndpointEvent.EndpointType endpoint_type = 1 [default = UNKNOWN];
  bool has_endpoint_type() const;
  private:
  bool _internal_has_endpoint_type() const;
  public:
  void clear_endpoint_type();
  ::speech::soda::chrome::SodaEndpointEvent_EndpointType endpoint_type() const;
  void set_endpoint_type(::speech::soda::chrome::SodaEndpointEvent_EndpointType value);
  private:
  ::speech::soda::chrome::SodaEndpointEvent_EndpointType _internal_endpoint_type() const;
  void _internal_set_endpoint_type(::speech::soda::chrome::SodaEndpointEvent_EndpointType value);
  public:

  // @@protoc_insertion_point(class_scope:speech.soda.chrome.SodaEndpointEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::speech::soda::chrome::TimingMetrics* timing_metrics_;
    int endpoint_type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_soda_5fapi_2eproto;
};
// -------------------------------------------------------------------

class SodaAudioLevelInfo final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:speech.soda.chrome.SodaAudioLevelInfo) */ {
 public:
  inline SodaAudioLevelInfo() : SodaAudioLevelInfo(nullptr) {}
  ~SodaAudioLevelInfo() override;
  explicit PROTOBUF_CONSTEXPR SodaAudioLevelInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SodaAudioLevelInfo(const SodaAudioLevelInfo& from);
  SodaAudioLevelInfo(SodaAudioLevelInfo&& from) noexcept
    : SodaAudioLevelInfo() {
    *this = ::std::move(from);
  }

  inline SodaAudioLevelInfo& operator=(const SodaAudioLevelInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline SodaAudioLevelInfo& operator=(SodaAudioLevelInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const SodaAudioLevelInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const SodaAudioLevelInfo* internal_default_instance() {
    return reinterpret_cast<const SodaAudioLevelInfo*>(
               &_SodaAudioLevelInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(SodaAudioLevelInfo& a, SodaAudioLevelInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(SodaAudioLevelInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SodaAudioLevelInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SodaAudioLevelInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SodaAudioLevelInfo>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const SodaAudioLevelInfo& from);
  void MergeFrom(const SodaAudioLevelInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SodaAudioLevelInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "speech.soda.chrome.SodaAudioLevelInfo";
  }
  protected:
  explicit SodaAudioLevelInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRmsFieldNumber = 1,
    kAudioLevelFieldNumber = 2,
    kAudioTimeUsecFieldNumber = 3,
  };
  // optional float rms = 1;
  bool has_rms() const;
  private:
  bool _internal_has_rms() const;
  public:
  void clear_rms();
  float rms() const;
  void set_rms(float value);
  private:
  float _internal_rms() const;
  void _internal_set_rms(float value);
  public:

  // optional float audio_level = 2;
  bool has_audio_level() const;
  private:
  bool _internal_has_audio_level() const;
  public:
  void clear_audio_level();
  float audio_level() const;
  void set_audio_level(float value);
  private:
  float _internal_audio_level() const;
  void _internal_set_audio_level(float value);
  public:

  // optional int64 audio_time_usec = 3;
  bool has_audio_time_usec() const;
  private:
  bool _internal_has_audio_time_usec() const;
  public:
  void clear_audio_time_usec();
  int64_t audio_time_usec() const;
  void set_audio_time_usec(int64_t value);
  private:
  int64_t _internal_audio_time_usec() const;
  void _internal_set_audio_time_usec(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:speech.soda.chrome.SodaAudioLevelInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    float rms_;
    float audio_level_;
    int64_t audio_time_usec_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_soda_5fapi_2eproto;
};
// -------------------------------------------------------------------

class SodaLangIdEvent final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:speech.soda.chrome.SodaLangIdEvent) */ {
 public:
  inline SodaLangIdEvent() : SodaLangIdEvent(nullptr) {}
  ~SodaLangIdEvent() override;
  explicit PROTOBUF_CONSTEXPR SodaLangIdEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SodaLangIdEvent(const SodaLangIdEvent& from);
  SodaLangIdEvent(SodaLangIdEvent&& from) noexcept
    : SodaLangIdEvent() {
    *this = ::std::move(from);
  }

  inline SodaLangIdEvent& operator=(const SodaLangIdEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline SodaLangIdEvent& operator=(SodaLangIdEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const SodaLangIdEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const SodaLangIdEvent* internal_default_instance() {
    return reinterpret_cast<const SodaLangIdEvent*>(
               &_SodaLangIdEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(SodaLangIdEvent& a, SodaLangIdEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(SodaLangIdEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SodaLangIdEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SodaLangIdEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SodaLangIdEvent>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const SodaLangIdEvent& from);
  void MergeFrom(const SodaLangIdEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SodaLangIdEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "speech.soda.chrome.SodaLangIdEvent";
  }
  protected:
  explicit SodaLangIdEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLanguageFieldNumber = 1,
    kConfidenceLevelFieldNumber = 2,
  };
  // optional string language = 1;
  bool has_language() const;
  private:
  bool _internal_has_language() const;
  public:
  void clear_language();
  const std::string& language() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_language(ArgT0&& arg0, ArgT... args);
  std::string* mutable_language();
  PROTOBUF_NODISCARD std::string* release_language();
  void set_allocated_language(std::string* language);
  private:
  const std::string& _internal_language() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_language(const std::string& value);
  std::string* _internal_mutable_language();
  public:

  // optional int32 confidence_level = 2;
  bool has_confidence_level() const;
  private:
  bool _internal_has_confidence_level() const;
  public:
  void clear_confidence_level();
  int32_t confidence_level() const;
  void set_confidence_level(int32_t value);
  private:
  int32_t _internal_confidence_level() const;
  void _internal_set_confidence_level(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:speech.soda.chrome.SodaLangIdEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr language_;
    int32_t confidence_level_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_soda_5fapi_2eproto;
};
// -------------------------------------------------------------------

class SodaResponse final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:speech.soda.chrome.SodaResponse) */ {
 public:
  inline SodaResponse() : SodaResponse(nullptr) {}
  ~SodaResponse() override;
  explicit PROTOBUF_CONSTEXPR SodaResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SodaResponse(const SodaResponse& from);
  SodaResponse(SodaResponse&& from) noexcept
    : SodaResponse() {
    *this = ::std::move(from);
  }

  inline SodaResponse& operator=(const SodaResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SodaResponse& operator=(SodaResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const SodaResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SodaResponse* internal_default_instance() {
    return reinterpret_cast<const SodaResponse*>(
               &_SodaResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(SodaResponse& a, SodaResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SodaResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SodaResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SodaResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SodaResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const SodaResponse& from);
  void MergeFrom(const SodaResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SodaResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "speech.soda.chrome.SodaResponse";
  }
  protected:
  explicit SodaResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef SodaResponse_SodaMessageType SodaMessageType;
  static constexpr SodaMessageType UNKNOWN =
    SodaResponse_SodaMessageType_UNKNOWN;
  static constexpr SodaMessageType RECOGNITION =
    SodaResponse_SodaMessageType_RECOGNITION;
  static constexpr SodaMessageType STOP =
    SodaResponse_SodaMessageType_STOP;
  static constexpr SodaMessageType SHUTDOWN =
    SodaResponse_SodaMessageType_SHUTDOWN;
  static constexpr SodaMessageType START =
    SodaResponse_SodaMessageType_START;
  static constexpr SodaMessageType ENDPOINT =
    SodaResponse_SodaMessageType_ENDPOINT;
  static constexpr SodaMessageType AUDIO_LEVEL =
    SodaResponse_SodaMessageType_AUDIO_LEVEL;
  static constexpr SodaMessageType LANGID =
    SodaResponse_SodaMessageType_LANGID;
  static constexpr SodaMessageType LOGS_ONLY_ARTIFICIAL_MESSAGE =
    SodaResponse_SodaMessageType_LOGS_ONLY_ARTIFICIAL_MESSAGE;
  static inline bool SodaMessageType_IsValid(int value) {
    return SodaResponse_SodaMessageType_IsValid(value);
  }
  static constexpr SodaMessageType SodaMessageType_MIN =
    SodaResponse_SodaMessageType_SodaMessageType_MIN;
  static constexpr SodaMessageType SodaMessageType_MAX =
    SodaResponse_SodaMessageType_SodaMessageType_MAX;
  static constexpr int SodaMessageType_ARRAYSIZE =
    SodaResponse_SodaMessageType_SodaMessageType_ARRAYSIZE;
  template<typename T>
  static inline const std::string& SodaMessageType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, SodaMessageType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function SodaMessageType_Name.");
    return SodaResponse_SodaMessageType_Name(enum_t_value);
  }
  static inline bool SodaMessageType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      SodaMessageType* value) {
    return SodaResponse_SodaMessageType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kLogLinesFieldNumber = 6,
    kRecognitionResultFieldNumber = 2,
    kEndpointEventFieldNumber = 3,
    kAudioLevelInfoFieldNumber = 4,
    kLangidEventFieldNumber = 5,
    kSodaTypeFieldNumber = 1,
  };
  // repeated string log_lines = 6;
  int log_lines_size() const;
  private:
  int _internal_log_lines_size() const;
  public:
  void clear_log_lines();
  const std::string& log_lines(int index) const;
  std::string* mutable_log_lines(int index);
  void set_log_lines(int index, const std::string& value);
  void set_log_lines(int index, std::string&& value);
  void set_log_lines(int index, const char* value);
  void set_log_lines(int index, const char* value, size_t size);
  std::string* add_log_lines();
  void add_log_lines(const std::string& value);
  void add_log_lines(std::string&& value);
  void add_log_lines(const char* value);
  void add_log_lines(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& log_lines() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_log_lines();
  private:
  const std::string& _internal_log_lines(int index) const;
  std::string* _internal_add_log_lines();
  public:

  // optional .speech.soda.chrome.SodaRecognitionResult recognition_result = 2;
  bool has_recognition_result() const;
  private:
  bool _internal_has_recognition_result() const;
  public:
  void clear_recognition_result();
  const ::speech::soda::chrome::SodaRecognitionResult& recognition_result() const;
  PROTOBUF_NODISCARD ::speech::soda::chrome::SodaRecognitionResult* release_recognition_result();
  ::speech::soda::chrome::SodaRecognitionResult* mutable_recognition_result();
  void set_allocated_recognition_result(::speech::soda::chrome::SodaRecognitionResult* recognition_result);
  private:
  const ::speech::soda::chrome::SodaRecognitionResult& _internal_recognition_result() const;
  ::speech::soda::chrome::SodaRecognitionResult* _internal_mutable_recognition_result();
  public:
  void unsafe_arena_set_allocated_recognition_result(
      ::speech::soda::chrome::SodaRecognitionResult* recognition_result);
  ::speech::soda::chrome::SodaRecognitionResult* unsafe_arena_release_recognition_result();

  // optional .speech.soda.chrome.SodaEndpointEvent endpoint_event = 3;
  bool has_endpoint_event() const;
  private:
  bool _internal_has_endpoint_event() const;
  public:
  void clear_endpoint_event();
  const ::speech::soda::chrome::SodaEndpointEvent& endpoint_event() const;
  PROTOBUF_NODISCARD ::speech::soda::chrome::SodaEndpointEvent* release_endpoint_event();
  ::speech::soda::chrome::SodaEndpointEvent* mutable_endpoint_event();
  void set_allocated_endpoint_event(::speech::soda::chrome::SodaEndpointEvent* endpoint_event);
  private:
  const ::speech::soda::chrome::SodaEndpointEvent& _internal_endpoint_event() const;
  ::speech::soda::chrome::SodaEndpointEvent* _internal_mutable_endpoint_event();
  public:
  void unsafe_arena_set_allocated_endpoint_event(
      ::speech::soda::chrome::SodaEndpointEvent* endpoint_event);
  ::speech::soda::chrome::SodaEndpointEvent* unsafe_arena_release_endpoint_event();

  // optional .speech.soda.chrome.SodaAudioLevelInfo audio_level_info = 4;
  bool has_audio_level_info() const;
  private:
  bool _internal_has_audio_level_info() const;
  public:
  void clear_audio_level_info();
  const ::speech::soda::chrome::SodaAudioLevelInfo& audio_level_info() const;
  PROTOBUF_NODISCARD ::speech::soda::chrome::SodaAudioLevelInfo* release_audio_level_info();
  ::speech::soda::chrome::SodaAudioLevelInfo* mutable_audio_level_info();
  void set_allocated_audio_level_info(::speech::soda::chrome::SodaAudioLevelInfo* audio_level_info);
  private:
  const ::speech::soda::chrome::SodaAudioLevelInfo& _internal_audio_level_info() const;
  ::speech::soda::chrome::SodaAudioLevelInfo* _internal_mutable_audio_level_info();
  public:
  void unsafe_arena_set_allocated_audio_level_info(
      ::speech::soda::chrome::SodaAudioLevelInfo* audio_level_info);
  ::speech::soda::chrome::SodaAudioLevelInfo* unsafe_arena_release_audio_level_info();

  // optional .speech.soda.chrome.SodaLangIdEvent langid_event = 5;
  bool has_langid_event() const;
  private:
  bool _internal_has_langid_event() const;
  public:
  void clear_langid_event();
  const ::speech::soda::chrome::SodaLangIdEvent& langid_event() const;
  PROTOBUF_NODISCARD ::speech::soda::chrome::SodaLangIdEvent* release_langid_event();
  ::speech::soda::chrome::SodaLangIdEvent* mutable_langid_event();
  void set_allocated_langid_event(::speech::soda::chrome::SodaLangIdEvent* langid_event);
  private:
  const ::speech::soda::chrome::SodaLangIdEvent& _internal_langid_event() const;
  ::speech::soda::chrome::SodaLangIdEvent* _internal_mutable_langid_event();
  public:
  void unsafe_arena_set_allocated_langid_event(
      ::speech::soda::chrome::SodaLangIdEvent* langid_event);
  ::speech::soda::chrome::SodaLangIdEvent* unsafe_arena_release_langid_event();

  // optional .speech.soda.chrome.SodaResponse.SodaMessageType soda_type = 1 [default = UNKNOWN];
  bool has_soda_type() const;
  private:
  bool _internal_has_soda_type() const;
  public:
  void clear_soda_type();
  ::speech::soda::chrome::SodaResponse_SodaMessageType soda_type() const;
  void set_soda_type(::speech::soda::chrome::SodaResponse_SodaMessageType value);
  private:
  ::speech::soda::chrome::SodaResponse_SodaMessageType _internal_soda_type() const;
  void _internal_set_soda_type(::speech::soda::chrome::SodaResponse_SodaMessageType value);
  public:

  // @@protoc_insertion_point(class_scope:speech.soda.chrome.SodaResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> log_lines_;
    ::speech::soda::chrome::SodaRecognitionResult* recognition_result_;
    ::speech::soda::chrome::SodaEndpointEvent* endpoint_event_;
    ::speech::soda::chrome::SodaAudioLevelInfo* audio_level_info_;
    ::speech::soda::chrome::SodaLangIdEvent* langid_event_;
    int soda_type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_soda_5fapi_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ExtendedSodaConfigMsg

// optional int32 channel_count = 1;
inline bool ExtendedSodaConfigMsg::_internal_has_channel_count() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool ExtendedSodaConfigMsg::has_channel_count() const {
  return _internal_has_channel_count();
}
inline void ExtendedSodaConfigMsg::clear_channel_count() {
  _impl_.channel_count_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline int32_t ExtendedSodaConfigMsg::_internal_channel_count() const {
  return _impl_.channel_count_;
}
inline int32_t ExtendedSodaConfigMsg::channel_count() const {
  // @@protoc_insertion_point(field_get:speech.soda.chrome.ExtendedSodaConfigMsg.channel_count)
  return _internal_channel_count();
}
inline void ExtendedSodaConfigMsg::_internal_set_channel_count(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.channel_count_ = value;
}
inline void ExtendedSodaConfigMsg::set_channel_count(int32_t value) {
  _internal_set_channel_count(value);
  // @@protoc_insertion_point(field_set:speech.soda.chrome.ExtendedSodaConfigMsg.channel_count)
}

// optional int32 sample_rate = 2;
inline bool ExtendedSodaConfigMsg::_internal_has_sample_rate() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool ExtendedSodaConfigMsg::has_sample_rate() const {
  return _internal_has_sample_rate();
}
inline void ExtendedSodaConfigMsg::clear_sample_rate() {
  _impl_.sample_rate_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline int32_t ExtendedSodaConfigMsg::_internal_sample_rate() const {
  return _impl_.sample_rate_;
}
inline int32_t ExtendedSodaConfigMsg::sample_rate() const {
  // @@protoc_insertion_point(field_get:speech.soda.chrome.ExtendedSodaConfigMsg.sample_rate)
  return _internal_sample_rate();
}
inline void ExtendedSodaConfigMsg::_internal_set_sample_rate(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.sample_rate_ = value;
}
inline void ExtendedSodaConfigMsg::set_sample_rate(int32_t value) {
  _internal_set_sample_rate(value);
  // @@protoc_insertion_point(field_set:speech.soda.chrome.ExtendedSodaConfigMsg.sample_rate)
}

// optional int32 max_buffer_bytes = 4 [default = 0];
inline bool ExtendedSodaConfigMsg::_internal_has_max_buffer_bytes() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool ExtendedSodaConfigMsg::has_max_buffer_bytes() const {
  return _internal_has_max_buffer_bytes();
}
inline void ExtendedSodaConfigMsg::clear_max_buffer_bytes() {
  _impl_.max_buffer_bytes_ = 0;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline int32_t ExtendedSodaConfigMsg::_internal_max_buffer_bytes() const {
  return _impl_.max_buffer_bytes_;
}
inline int32_t ExtendedSodaConfigMsg::max_buffer_bytes() const {
  // @@protoc_insertion_point(field_get:speech.soda.chrome.ExtendedSodaConfigMsg.max_buffer_bytes)
  return _internal_max_buffer_bytes();
}
inline void ExtendedSodaConfigMsg::_internal_set_max_buffer_bytes(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.max_buffer_bytes_ = value;
}
inline void ExtendedSodaConfigMsg::set_max_buffer_bytes(int32_t value) {
  _internal_set_max_buffer_bytes(value);
  // @@protoc_insertion_point(field_set:speech.soda.chrome.ExtendedSodaConfigMsg.max_buffer_bytes)
}

// optional bool simulate_realtime_testonly = 5 [default = false];
inline bool ExtendedSodaConfigMsg::_internal_has_simulate_realtime_testonly() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool ExtendedSodaConfigMsg::has_simulate_realtime_testonly() const {
  return _internal_has_simulate_realtime_testonly();
}
inline void ExtendedSodaConfigMsg::clear_simulate_realtime_testonly() {
  _impl_.simulate_realtime_testonly_ = false;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline bool ExtendedSodaConfigMsg::_internal_simulate_realtime_testonly() const {
  return _impl_.simulate_realtime_testonly_;
}
inline bool ExtendedSodaConfigMsg::simulate_realtime_testonly() const {
  // @@protoc_insertion_point(field_get:speech.soda.chrome.ExtendedSodaConfigMsg.simulate_realtime_testonly)
  return _internal_simulate_realtime_testonly();
}
inline void ExtendedSodaConfigMsg::_internal_set_simulate_realtime_testonly(bool value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.simulate_realtime_testonly_ = value;
}
inline void ExtendedSodaConfigMsg::set_simulate_realtime_testonly(bool value) {
  _internal_set_simulate_realtime_testonly(value);
  // @@protoc_insertion_point(field_set:speech.soda.chrome.ExtendedSodaConfigMsg.simulate_realtime_testonly)
}

// optional string config_file_location = 3 [deprecated = true];
inline bool ExtendedSodaConfigMsg::_internal_has_config_file_location() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ExtendedSodaConfigMsg::has_config_file_location() const {
  return _internal_has_config_file_location();
}
inline void ExtendedSodaConfigMsg::clear_config_file_location() {
  _impl_.config_file_location_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ExtendedSodaConfigMsg::config_file_location() const {
  // @@protoc_insertion_point(field_get:speech.soda.chrome.ExtendedSodaConfigMsg.config_file_location)
  return _internal_config_file_location();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ExtendedSodaConfigMsg::set_config_file_location(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.config_file_location_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:speech.soda.chrome.ExtendedSodaConfigMsg.config_file_location)
}
inline std::string* ExtendedSodaConfigMsg::mutable_config_file_location() {
  std::string* _s = _internal_mutable_config_file_location();
  // @@protoc_insertion_point(field_mutable:speech.soda.chrome.ExtendedSodaConfigMsg.config_file_location)
  return _s;
}
inline const std::string& ExtendedSodaConfigMsg::_internal_config_file_location() const {
  return _impl_.config_file_location_.Get();
}
inline void ExtendedSodaConfigMsg::_internal_set_config_file_location(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.config_file_location_.Set(value, GetArenaForAllocation());
}
inline std::string* ExtendedSodaConfigMsg::_internal_mutable_config_file_location() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.config_file_location_.Mutable(GetArenaForAllocation());
}
inline std::string* ExtendedSodaConfigMsg::release_config_file_location() {
  // @@protoc_insertion_point(field_release:speech.soda.chrome.ExtendedSodaConfigMsg.config_file_location)
  if (!_internal_has_config_file_location()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.config_file_location_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.config_file_location_.IsDefault()) {
    _impl_.config_file_location_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ExtendedSodaConfigMsg::set_allocated_config_file_location(std::string* config_file_location) {
  if (config_file_location != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.config_file_location_.SetAllocated(config_file_location, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.config_file_location_.IsDefault()) {
    _impl_.config_file_location_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:speech.soda.chrome.ExtendedSodaConfigMsg.config_file_location)
}

// optional string api_key = 6;
inline bool ExtendedSodaConfigMsg::_internal_has_api_key() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ExtendedSodaConfigMsg::has_api_key() const {
  return _internal_has_api_key();
}
inline void ExtendedSodaConfigMsg::clear_api_key() {
  _impl_.api_key_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ExtendedSodaConfigMsg::api_key() const {
  // @@protoc_insertion_point(field_get:speech.soda.chrome.ExtendedSodaConfigMsg.api_key)
  return _internal_api_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ExtendedSodaConfigMsg::set_api_key(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.api_key_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:speech.soda.chrome.ExtendedSodaConfigMsg.api_key)
}
inline std::string* ExtendedSodaConfigMsg::mutable_api_key() {
  std::string* _s = _internal_mutable_api_key();
  // @@protoc_insertion_point(field_mutable:speech.soda.chrome.ExtendedSodaConfigMsg.api_key)
  return _s;
}
inline const std::string& ExtendedSodaConfigMsg::_internal_api_key() const {
  return _impl_.api_key_.Get();
}
inline void ExtendedSodaConfigMsg::_internal_set_api_key(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.api_key_.Set(value, GetArenaForAllocation());
}
inline std::string* ExtendedSodaConfigMsg::_internal_mutable_api_key() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.api_key_.Mutable(GetArenaForAllocation());
}
inline std::string* ExtendedSodaConfigMsg::release_api_key() {
  // @@protoc_insertion_point(field_release:speech.soda.chrome.ExtendedSodaConfigMsg.api_key)
  if (!_internal_has_api_key()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.api_key_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.api_key_.IsDefault()) {
    _impl_.api_key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ExtendedSodaConfigMsg::set_allocated_api_key(std::string* api_key) {
  if (api_key != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.api_key_.SetAllocated(api_key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.api_key_.IsDefault()) {
    _impl_.api_key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:speech.soda.chrome.ExtendedSodaConfigMsg.api_key)
}

// optional string language_pack_directory = 7;
inline bool ExtendedSodaConfigMsg::_internal_has_language_pack_directory() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ExtendedSodaConfigMsg::has_language_pack_directory() const {
  return _internal_has_language_pack_directory();
}
inline void ExtendedSodaConfigMsg::clear_language_pack_directory() {
  _impl_.language_pack_directory_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& ExtendedSodaConfigMsg::language_pack_directory() const {
  // @@protoc_insertion_point(field_get:speech.soda.chrome.ExtendedSodaConfigMsg.language_pack_directory)
  return _internal_language_pack_directory();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ExtendedSodaConfigMsg::set_language_pack_directory(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.language_pack_directory_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:speech.soda.chrome.ExtendedSodaConfigMsg.language_pack_directory)
}
inline std::string* ExtendedSodaConfigMsg::mutable_language_pack_directory() {
  std::string* _s = _internal_mutable_language_pack_directory();
  // @@protoc_insertion_point(field_mutable:speech.soda.chrome.ExtendedSodaConfigMsg.language_pack_directory)
  return _s;
}
inline const std::string& ExtendedSodaConfigMsg::_internal_language_pack_directory() const {
  return _impl_.language_pack_directory_.Get();
}
inline void ExtendedSodaConfigMsg::_internal_set_language_pack_directory(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.language_pack_directory_.Set(value, GetArenaForAllocation());
}
inline std::string* ExtendedSodaConfigMsg::_internal_mutable_language_pack_directory() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.language_pack_directory_.Mutable(GetArenaForAllocation());
}
inline std::string* ExtendedSodaConfigMsg::release_language_pack_directory() {
  // @@protoc_insertion_point(field_release:speech.soda.chrome.ExtendedSodaConfigMsg.language_pack_directory)
  if (!_internal_has_language_pack_directory()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.language_pack_directory_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.language_pack_directory_.IsDefault()) {
    _impl_.language_pack_directory_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ExtendedSodaConfigMsg::set_allocated_language_pack_directory(std::string* language_pack_directory) {
  if (language_pack_directory != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.language_pack_directory_.SetAllocated(language_pack_directory, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.language_pack_directory_.IsDefault()) {
    _impl_.language_pack_directory_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:speech.soda.chrome.ExtendedSodaConfigMsg.language_pack_directory)
}

// optional .speech.soda.chrome.ExtendedSodaConfigMsg.RecognitionMode recognition_mode = 8 [default = IME];
inline bool ExtendedSodaConfigMsg::_internal_has_recognition_mode() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool ExtendedSodaConfigMsg::has_recognition_mode() const {
  return _internal_has_recognition_mode();
}
inline void ExtendedSodaConfigMsg::clear_recognition_mode() {
  _impl_.recognition_mode_ = 1;
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline ::speech::soda::chrome::ExtendedSodaConfigMsg_RecognitionMode ExtendedSodaConfigMsg::_internal_recognition_mode() const {
  return static_cast< ::speech::soda::chrome::ExtendedSodaConfigMsg_RecognitionMode >(_impl_.recognition_mode_);
}
inline ::speech::soda::chrome::ExtendedSodaConfigMsg_RecognitionMode ExtendedSodaConfigMsg::recognition_mode() const {
  // @@protoc_insertion_point(field_get:speech.soda.chrome.ExtendedSodaConfigMsg.recognition_mode)
  return _internal_recognition_mode();
}
inline void ExtendedSodaConfigMsg::_internal_set_recognition_mode(::speech::soda::chrome::ExtendedSodaConfigMsg_RecognitionMode value) {
  assert(::speech::soda::chrome::ExtendedSodaConfigMsg_RecognitionMode_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000800u;
  _impl_.recognition_mode_ = value;
}
inline void ExtendedSodaConfigMsg::set_recognition_mode(::speech::soda::chrome::ExtendedSodaConfigMsg_RecognitionMode value) {
  _internal_set_recognition_mode(value);
  // @@protoc_insertion_point(field_set:speech.soda.chrome.ExtendedSodaConfigMsg.recognition_mode)
}

// optional bool reset_on_final_result = 9 [default = true, deprecated = true];
inline bool ExtendedSodaConfigMsg::_internal_has_reset_on_final_result() const {
  bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool ExtendedSodaConfigMsg::has_reset_on_final_result() const {
  return _internal_has_reset_on_final_result();
}
inline void ExtendedSodaConfigMsg::clear_reset_on_final_result() {
  _impl_.reset_on_final_result_ = true;
  _impl_._has_bits_[0] &= ~0x00001000u;
}
inline bool ExtendedSodaConfigMsg::_internal_reset_on_final_result() const {
  return _impl_.reset_on_final_result_;
}
inline bool ExtendedSodaConfigMsg::reset_on_final_result() const {
  // @@protoc_insertion_point(field_get:speech.soda.chrome.ExtendedSodaConfigMsg.reset_on_final_result)
  return _internal_reset_on_final_result();
}
inline void ExtendedSodaConfigMsg::_internal_set_reset_on_final_result(bool value) {
  _impl_._has_bits_[0] |= 0x00001000u;
  _impl_.reset_on_final_result_ = value;
}
inline void ExtendedSodaConfigMsg::set_reset_on_final_result(bool value) {
  _internal_set_reset_on_final_result(value);
  // @@protoc_insertion_point(field_set:speech.soda.chrome.ExtendedSodaConfigMsg.reset_on_final_result)
}

// optional bool include_timing_metrics = 10 [default = true];
inline bool ExtendedSodaConfigMsg::_internal_has_include_timing_metrics() const {
  bool value = (_impl_._has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool ExtendedSodaConfigMsg::has_include_timing_metrics() const {
  return _internal_has_include_timing_metrics();
}
inline void ExtendedSodaConfigMsg::clear_include_timing_metrics() {
  _impl_.include_timing_metrics_ = true;
  _impl_._has_bits_[0] &= ~0x00002000u;
}
inline bool ExtendedSodaConfigMsg::_internal_include_timing_metrics() const {
  return _impl_.include_timing_metrics_;
}
inline bool ExtendedSodaConfigMsg::include_timing_metrics() const {
  // @@protoc_insertion_point(field_get:speech.soda.chrome.ExtendedSodaConfigMsg.include_timing_metrics)
  return _internal_include_timing_metrics();
}
inline void ExtendedSodaConfigMsg::_internal_set_include_timing_metrics(bool value) {
  _impl_._has_bits_[0] |= 0x00002000u;
  _impl_.include_timing_metrics_ = value;
}
inline void ExtendedSodaConfigMsg::set_include_timing_metrics(bool value) {
  _internal_set_include_timing_metrics(value);
  // @@protoc_insertion_point(field_set:speech.soda.chrome.ExtendedSodaConfigMsg.include_timing_metrics)
}

// optional bool enable_lang_id = 11 [default = false];
inline bool ExtendedSodaConfigMsg::_internal_has_enable_lang_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool ExtendedSodaConfigMsg::has_enable_lang_id() const {
  return _internal_has_enable_lang_id();
}
inline void ExtendedSodaConfigMsg::clear_enable_lang_id() {
  _impl_.enable_lang_id_ = false;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline bool ExtendedSodaConfigMsg::_internal_enable_lang_id() const {
  return _impl_.enable_lang_id_;
}
inline bool ExtendedSodaConfigMsg::enable_lang_id() const {
  // @@protoc_insertion_point(field_get:speech.soda.chrome.ExtendedSodaConfigMsg.enable_lang_id)
  return _internal_enable_lang_id();
}
inline void ExtendedSodaConfigMsg::_internal_set_enable_lang_id(bool value) {
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.enable_lang_id_ = value;
}
inline void ExtendedSodaConfigMsg::set_enable_lang_id(bool value) {
  _internal_set_enable_lang_id(value);
  // @@protoc_insertion_point(field_set:speech.soda.chrome.ExtendedSodaConfigMsg.enable_lang_id)
}

// optional bool enable_formatting = 12 [default = true];
inline bool ExtendedSodaConfigMsg::_internal_has_enable_formatting() const {
  bool value = (_impl_._has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool ExtendedSodaConfigMsg::has_enable_formatting() const {
  return _internal_has_enable_formatting();
}
inline void ExtendedSodaConfigMsg::clear_enable_formatting() {
  _impl_.enable_formatting_ = true;
  _impl_._has_bits_[0] &= ~0x00004000u;
}
inline bool ExtendedSodaConfigMsg::_internal_enable_formatting() const {
  return _impl_.enable_formatting_;
}
inline bool ExtendedSodaConfigMsg::enable_formatting() const {
  // @@protoc_insertion_point(field_get:speech.soda.chrome.ExtendedSodaConfigMsg.enable_formatting)
  return _internal_enable_formatting();
}
inline void ExtendedSodaConfigMsg::_internal_set_enable_formatting(bool value) {
  _impl_._has_bits_[0] |= 0x00004000u;
  _impl_.enable_formatting_ = value;
}
inline void ExtendedSodaConfigMsg::set_enable_formatting(bool value) {
  _internal_set_enable_formatting(value);
  // @@protoc_insertion_point(field_set:speech.soda.chrome.ExtendedSodaConfigMsg.enable_formatting)
}

// optional bool enable_speaker_change_detection = 13 [default = false];
inline bool ExtendedSodaConfigMsg::_internal_has_enable_speaker_change_detection() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool ExtendedSodaConfigMsg::has_enable_speaker_change_detection() const {
  return _internal_has_enable_speaker_change_detection();
}
inline void ExtendedSodaConfigMsg::clear_enable_speaker_change_detection() {
  _impl_.enable_speaker_change_detection_ = false;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline bool ExtendedSodaConfigMsg::_internal_enable_speaker_change_detection() const {
  return _impl_.enable_speaker_change_detection_;
}
inline bool ExtendedSodaConfigMsg::enable_speaker_change_detection() const {
  // @@protoc_insertion_point(field_get:speech.soda.chrome.ExtendedSodaConfigMsg.enable_speaker_change_detection)
  return _internal_enable_speaker_change_detection();
}
inline void ExtendedSodaConfigMsg::_internal_set_enable_speaker_change_detection(bool value) {
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.enable_speaker_change_detection_ = value;
}
inline void ExtendedSodaConfigMsg::set_enable_speaker_change_detection(bool value) {
  _internal_set_enable_speaker_change_detection(value);
  // @@protoc_insertion_point(field_set:speech.soda.chrome.ExtendedSodaConfigMsg.enable_speaker_change_detection)
}

// optional bool include_logging = 14 [default = false];
inline bool ExtendedSodaConfigMsg::_internal_has_include_logging() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool ExtendedSodaConfigMsg::has_include_logging() const {
  return _internal_has_include_logging();
}
inline void ExtendedSodaConfigMsg::clear_include_logging() {
  _impl_.include_logging_ = false;
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline bool ExtendedSodaConfigMsg::_internal_include_logging() const {
  return _impl_.include_logging_;
}
inline bool ExtendedSodaConfigMsg::include_logging() const {
  // @@protoc_insertion_point(field_get:speech.soda.chrome.ExtendedSodaConfigMsg.include_logging)
  return _internal_include_logging();
}
inline void ExtendedSodaConfigMsg::_internal_set_include_logging(bool value) {
  _impl_._has_bits_[0] |= 0x00000400u;
  _impl_.include_logging_ = value;
}
inline void ExtendedSodaConfigMsg::set_include_logging(bool value) {
  _internal_set_include_logging(value);
  // @@protoc_insertion_point(field_set:speech.soda.chrome.ExtendedSodaConfigMsg.include_logging)
}

// optional .speech.soda.chrome.MultilangConfig multilang_config = 15;
inline bool ExtendedSodaConfigMsg::_internal_has_multilang_config() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.multilang_config_ != nullptr);
  return value;
}
inline bool ExtendedSodaConfigMsg::has_multilang_config() const {
  return _internal_has_multilang_config();
}
inline void ExtendedSodaConfigMsg::clear_multilang_config() {
  if (_impl_.multilang_config_ != nullptr) _impl_.multilang_config_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::speech::soda::chrome::MultilangConfig& ExtendedSodaConfigMsg::_internal_multilang_config() const {
  const ::speech::soda::chrome::MultilangConfig* p = _impl_.multilang_config_;
  return p != nullptr ? *p : reinterpret_cast<const ::speech::soda::chrome::MultilangConfig&>(
      ::speech::soda::chrome::_MultilangConfig_default_instance_);
}
inline const ::speech::soda::chrome::MultilangConfig& ExtendedSodaConfigMsg::multilang_config() const {
  // @@protoc_insertion_point(field_get:speech.soda.chrome.ExtendedSodaConfigMsg.multilang_config)
  return _internal_multilang_config();
}
inline void ExtendedSodaConfigMsg::unsafe_arena_set_allocated_multilang_config(
    ::speech::soda::chrome::MultilangConfig* multilang_config) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.multilang_config_);
  }
  _impl_.multilang_config_ = multilang_config;
  if (multilang_config) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:speech.soda.chrome.ExtendedSodaConfigMsg.multilang_config)
}
inline ::speech::soda::chrome::MultilangConfig* ExtendedSodaConfigMsg::release_multilang_config() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::speech::soda::chrome::MultilangConfig* temp = _impl_.multilang_config_;
  _impl_.multilang_config_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::speech::soda::chrome::MultilangConfig* ExtendedSodaConfigMsg::unsafe_arena_release_multilang_config() {
  // @@protoc_insertion_point(field_release:speech.soda.chrome.ExtendedSodaConfigMsg.multilang_config)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::speech::soda::chrome::MultilangConfig* temp = _impl_.multilang_config_;
  _impl_.multilang_config_ = nullptr;
  return temp;
}
inline ::speech::soda::chrome::MultilangConfig* ExtendedSodaConfigMsg::_internal_mutable_multilang_config() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.multilang_config_ == nullptr) {
    auto* p = CreateMaybeMessage<::speech::soda::chrome::MultilangConfig>(GetArenaForAllocation());
    _impl_.multilang_config_ = p;
  }
  return _impl_.multilang_config_;
}
inline ::speech::soda::chrome::MultilangConfig* ExtendedSodaConfigMsg::mutable_multilang_config() {
  ::speech::soda::chrome::MultilangConfig* _msg = _internal_mutable_multilang_config();
  // @@protoc_insertion_point(field_mutable:speech.soda.chrome.ExtendedSodaConfigMsg.multilang_config)
  return _msg;
}
inline void ExtendedSodaConfigMsg::set_allocated_multilang_config(::speech::soda::chrome::MultilangConfig* multilang_config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.multilang_config_;
  }
  if (multilang_config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(multilang_config);
    if (message_arena != submessage_arena) {
      multilang_config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, multilang_config, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.multilang_config_ = multilang_config;
  // @@protoc_insertion_point(field_set_allocated:speech.soda.chrome.ExtendedSodaConfigMsg.multilang_config)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// MultilangConfig

// map<string, string> multilang_language_pack_directory = 1;
inline int MultilangConfig::_internal_multilang_language_pack_directory_size() const {
  return _impl_.multilang_language_pack_directory_.size();
}
inline int MultilangConfig::multilang_language_pack_directory_size() const {
  return _internal_multilang_language_pack_directory_size();
}
inline void MultilangConfig::clear_multilang_language_pack_directory() {
  _impl_.multilang_language_pack_directory_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
MultilangConfig::_internal_multilang_language_pack_directory() const {
  return _impl_.multilang_language_pack_directory_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
MultilangConfig::multilang_language_pack_directory() const {
  // @@protoc_insertion_point(field_map:speech.soda.chrome.MultilangConfig.multilang_language_pack_directory)
  return _internal_multilang_language_pack_directory();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
MultilangConfig::_internal_mutable_multilang_language_pack_directory() {
  return _impl_.multilang_language_pack_directory_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
MultilangConfig::mutable_multilang_language_pack_directory() {
  // @@protoc_insertion_point(field_mutable_map:speech.soda.chrome.MultilangConfig.multilang_language_pack_directory)
  return _internal_mutable_multilang_language_pack_directory();
}

// optional bool rewind_when_switching_language = 2;
inline bool MultilangConfig::_internal_has_rewind_when_switching_language() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MultilangConfig::has_rewind_when_switching_language() const {
  return _internal_has_rewind_when_switching_language();
}
inline void MultilangConfig::clear_rewind_when_switching_language() {
  _impl_.rewind_when_switching_language_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool MultilangConfig::_internal_rewind_when_switching_language() const {
  return _impl_.rewind_when_switching_language_;
}
inline bool MultilangConfig::rewind_when_switching_language() const {
  // @@protoc_insertion_point(field_get:speech.soda.chrome.MultilangConfig.rewind_when_switching_language)
  return _internal_rewind_when_switching_language();
}
inline void MultilangConfig::_internal_set_rewind_when_switching_language(bool value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.rewind_when_switching_language_ = value;
}
inline void MultilangConfig::set_rewind_when_switching_language(bool value) {
  _internal_set_rewind_when_switching_language(value);
  // @@protoc_insertion_point(field_set:speech.soda.chrome.MultilangConfig.rewind_when_switching_language)
}

// -------------------------------------------------------------------

// TimingMetrics

// optional int64 audio_start_epoch_usec = 1;
inline bool TimingMetrics::_internal_has_audio_start_epoch_usec() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TimingMetrics::has_audio_start_epoch_usec() const {
  return _internal_has_audio_start_epoch_usec();
}
inline void TimingMetrics::clear_audio_start_epoch_usec() {
  _impl_.audio_start_epoch_usec_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int64_t TimingMetrics::_internal_audio_start_epoch_usec() const {
  return _impl_.audio_start_epoch_usec_;
}
inline int64_t TimingMetrics::audio_start_epoch_usec() const {
  // @@protoc_insertion_point(field_get:speech.soda.chrome.TimingMetrics.audio_start_epoch_usec)
  return _internal_audio_start_epoch_usec();
}
inline void TimingMetrics::_internal_set_audio_start_epoch_usec(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.audio_start_epoch_usec_ = value;
}
inline void TimingMetrics::set_audio_start_epoch_usec(int64_t value) {
  _internal_set_audio_start_epoch_usec(value);
  // @@protoc_insertion_point(field_set:speech.soda.chrome.TimingMetrics.audio_start_epoch_usec)
}

// optional int64 audio_start_time_usec = 2;
inline bool TimingMetrics::_internal_has_audio_start_time_usec() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TimingMetrics::has_audio_start_time_usec() const {
  return _internal_has_audio_start_time_usec();
}
inline void TimingMetrics::clear_audio_start_time_usec() {
  _impl_.audio_start_time_usec_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int64_t TimingMetrics::_internal_audio_start_time_usec() const {
  return _impl_.audio_start_time_usec_;
}
inline int64_t TimingMetrics::audio_start_time_usec() const {
  // @@protoc_insertion_point(field_get:speech.soda.chrome.TimingMetrics.audio_start_time_usec)
  return _internal_audio_start_time_usec();
}
inline void TimingMetrics::_internal_set_audio_start_time_usec(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.audio_start_time_usec_ = value;
}
inline void TimingMetrics::set_audio_start_time_usec(int64_t value) {
  _internal_set_audio_start_time_usec(value);
  // @@protoc_insertion_point(field_set:speech.soda.chrome.TimingMetrics.audio_start_time_usec)
}

// optional int64 elapsed_wall_time_usec = 3;
inline bool TimingMetrics::_internal_has_elapsed_wall_time_usec() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool TimingMetrics::has_elapsed_wall_time_usec() const {
  return _internal_has_elapsed_wall_time_usec();
}
inline void TimingMetrics::clear_elapsed_wall_time_usec() {
  _impl_.elapsed_wall_time_usec_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int64_t TimingMetrics::_internal_elapsed_wall_time_usec() const {
  return _impl_.elapsed_wall_time_usec_;
}
inline int64_t TimingMetrics::elapsed_wall_time_usec() const {
  // @@protoc_insertion_point(field_get:speech.soda.chrome.TimingMetrics.elapsed_wall_time_usec)
  return _internal_elapsed_wall_time_usec();
}
inline void TimingMetrics::_internal_set_elapsed_wall_time_usec(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.elapsed_wall_time_usec_ = value;
}
inline void TimingMetrics::set_elapsed_wall_time_usec(int64_t value) {
  _internal_set_elapsed_wall_time_usec(value);
  // @@protoc_insertion_point(field_set:speech.soda.chrome.TimingMetrics.elapsed_wall_time_usec)
}

// optional int64 event_end_time_usec = 4;
inline bool TimingMetrics::_internal_has_event_end_time_usec() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool TimingMetrics::has_event_end_time_usec() const {
  return _internal_has_event_end_time_usec();
}
inline void TimingMetrics::clear_event_end_time_usec() {
  _impl_.event_end_time_usec_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline int64_t TimingMetrics::_internal_event_end_time_usec() const {
  return _impl_.event_end_time_usec_;
}
inline int64_t TimingMetrics::event_end_time_usec() const {
  // @@protoc_insertion_point(field_get:speech.soda.chrome.TimingMetrics.event_end_time_usec)
  return _internal_event_end_time_usec();
}
inline void TimingMetrics::_internal_set_event_end_time_usec(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.event_end_time_usec_ = value;
}
inline void TimingMetrics::set_event_end_time_usec(int64_t value) {
  _internal_set_event_end_time_usec(value);
  // @@protoc_insertion_point(field_set:speech.soda.chrome.TimingMetrics.event_end_time_usec)
}

// -------------------------------------------------------------------

// HypothesisPart

// repeated string text = 1;
inline int HypothesisPart::_internal_text_size() const {
  return _impl_.text_.size();
}
inline int HypothesisPart::text_size() const {
  return _internal_text_size();
}
inline void HypothesisPart::clear_text() {
  _impl_.text_.Clear();
}
inline std::string* HypothesisPart::add_text() {
  std::string* _s = _internal_add_text();
  // @@protoc_insertion_point(field_add_mutable:speech.soda.chrome.HypothesisPart.text)
  return _s;
}
inline const std::string& HypothesisPart::_internal_text(int index) const {
  return _impl_.text_.Get(index);
}
inline const std::string& HypothesisPart::text(int index) const {
  // @@protoc_insertion_point(field_get:speech.soda.chrome.HypothesisPart.text)
  return _internal_text(index);
}
inline std::string* HypothesisPart::mutable_text(int index) {
  // @@protoc_insertion_point(field_mutable:speech.soda.chrome.HypothesisPart.text)
  return _impl_.text_.Mutable(index);
}
inline void HypothesisPart::set_text(int index, const std::string& value) {
  _impl_.text_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:speech.soda.chrome.HypothesisPart.text)
}
inline void HypothesisPart::set_text(int index, std::string&& value) {
  _impl_.text_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:speech.soda.chrome.HypothesisPart.text)
}
inline void HypothesisPart::set_text(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.text_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:speech.soda.chrome.HypothesisPart.text)
}
inline void HypothesisPart::set_text(int index, const char* value, size_t size) {
  _impl_.text_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:speech.soda.chrome.HypothesisPart.text)
}
inline std::string* HypothesisPart::_internal_add_text() {
  return _impl_.text_.Add();
}
inline void HypothesisPart::add_text(const std::string& value) {
  _impl_.text_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:speech.soda.chrome.HypothesisPart.text)
}
inline void HypothesisPart::add_text(std::string&& value) {
  _impl_.text_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:speech.soda.chrome.HypothesisPart.text)
}
inline void HypothesisPart::add_text(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.text_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:speech.soda.chrome.HypothesisPart.text)
}
inline void HypothesisPart::add_text(const char* value, size_t size) {
  _impl_.text_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:speech.soda.chrome.HypothesisPart.text)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
HypothesisPart::text() const {
  // @@protoc_insertion_point(field_list:speech.soda.chrome.HypothesisPart.text)
  return _impl_.text_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
HypothesisPart::mutable_text() {
  // @@protoc_insertion_point(field_mutable_list:speech.soda.chrome.HypothesisPart.text)
  return &_impl_.text_;
}

// optional int64 alignment_ms = 2;
inline bool HypothesisPart::_internal_has_alignment_ms() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool HypothesisPart::has_alignment_ms() const {
  return _internal_has_alignment_ms();
}
inline void HypothesisPart::clear_alignment_ms() {
  _impl_.alignment_ms_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int64_t HypothesisPart::_internal_alignment_ms() const {
  return _impl_.alignment_ms_;
}
inline int64_t HypothesisPart::alignment_ms() const {
  // @@protoc_insertion_point(field_get:speech.soda.chrome.HypothesisPart.alignment_ms)
  return _internal_alignment_ms();
}
inline void HypothesisPart::_internal_set_alignment_ms(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.alignment_ms_ = value;
}
inline void HypothesisPart::set_alignment_ms(int64_t value) {
  _internal_set_alignment_ms(value);
  // @@protoc_insertion_point(field_set:speech.soda.chrome.HypothesisPart.alignment_ms)
}

// -------------------------------------------------------------------

// SodaRecognitionResult

// repeated string hypothesis = 1;
inline int SodaRecognitionResult::_internal_hypothesis_size() const {
  return _impl_.hypothesis_.size();
}
inline int SodaRecognitionResult::hypothesis_size() const {
  return _internal_hypothesis_size();
}
inline void SodaRecognitionResult::clear_hypothesis() {
  _impl_.hypothesis_.Clear();
}
inline std::string* SodaRecognitionResult::add_hypothesis() {
  std::string* _s = _internal_add_hypothesis();
  // @@protoc_insertion_point(field_add_mutable:speech.soda.chrome.SodaRecognitionResult.hypothesis)
  return _s;
}
inline const std::string& SodaRecognitionResult::_internal_hypothesis(int index) const {
  return _impl_.hypothesis_.Get(index);
}
inline const std::string& SodaRecognitionResult::hypothesis(int index) const {
  // @@protoc_insertion_point(field_get:speech.soda.chrome.SodaRecognitionResult.hypothesis)
  return _internal_hypothesis(index);
}
inline std::string* SodaRecognitionResult::mutable_hypothesis(int index) {
  // @@protoc_insertion_point(field_mutable:speech.soda.chrome.SodaRecognitionResult.hypothesis)
  return _impl_.hypothesis_.Mutable(index);
}
inline void SodaRecognitionResult::set_hypothesis(int index, const std::string& value) {
  _impl_.hypothesis_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:speech.soda.chrome.SodaRecognitionResult.hypothesis)
}
inline void SodaRecognitionResult::set_hypothesis(int index, std::string&& value) {
  _impl_.hypothesis_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:speech.soda.chrome.SodaRecognitionResult.hypothesis)
}
inline void SodaRecognitionResult::set_hypothesis(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.hypothesis_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:speech.soda.chrome.SodaRecognitionResult.hypothesis)
}
inline void SodaRecognitionResult::set_hypothesis(int index, const char* value, size_t size) {
  _impl_.hypothesis_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:speech.soda.chrome.SodaRecognitionResult.hypothesis)
}
inline std::string* SodaRecognitionResult::_internal_add_hypothesis() {
  return _impl_.hypothesis_.Add();
}
inline void SodaRecognitionResult::add_hypothesis(const std::string& value) {
  _impl_.hypothesis_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:speech.soda.chrome.SodaRecognitionResult.hypothesis)
}
inline void SodaRecognitionResult::add_hypothesis(std::string&& value) {
  _impl_.hypothesis_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:speech.soda.chrome.SodaRecognitionResult.hypothesis)
}
inline void SodaRecognitionResult::add_hypothesis(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.hypothesis_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:speech.soda.chrome.SodaRecognitionResult.hypothesis)
}
inline void SodaRecognitionResult::add_hypothesis(const char* value, size_t size) {
  _impl_.hypothesis_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:speech.soda.chrome.SodaRecognitionResult.hypothesis)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
SodaRecognitionResult::hypothesis() const {
  // @@protoc_insertion_point(field_list:speech.soda.chrome.SodaRecognitionResult.hypothesis)
  return _impl_.hypothesis_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
SodaRecognitionResult::mutable_hypothesis() {
  // @@protoc_insertion_point(field_mutable_list:speech.soda.chrome.SodaRecognitionResult.hypothesis)
  return &_impl_.hypothesis_;
}

// optional .speech.soda.chrome.SodaRecognitionResult.ResultType result_type = 2;
inline bool SodaRecognitionResult::_internal_has_result_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SodaRecognitionResult::has_result_type() const {
  return _internal_has_result_type();
}
inline void SodaRecognitionResult::clear_result_type() {
  _impl_.result_type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::speech::soda::chrome::SodaRecognitionResult_ResultType SodaRecognitionResult::_internal_result_type() const {
  return static_cast< ::speech::soda::chrome::SodaRecognitionResult_ResultType >(_impl_.result_type_);
}
inline ::speech::soda::chrome::SodaRecognitionResult_ResultType SodaRecognitionResult::result_type() const {
  // @@protoc_insertion_point(field_get:speech.soda.chrome.SodaRecognitionResult.result_type)
  return _internal_result_type();
}
inline void SodaRecognitionResult::_internal_set_result_type(::speech::soda::chrome::SodaRecognitionResult_ResultType value) {
  assert(::speech::soda::chrome::SodaRecognitionResult_ResultType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.result_type_ = value;
}
inline void SodaRecognitionResult::set_result_type(::speech::soda::chrome::SodaRecognitionResult_ResultType value) {
  _internal_set_result_type(value);
  // @@protoc_insertion_point(field_set:speech.soda.chrome.SodaRecognitionResult.result_type)
}

// optional .speech.soda.chrome.SodaRecognitionResult.FinalResultEndpointReason endpoint_reason = 3;
inline bool SodaRecognitionResult::_internal_has_endpoint_reason() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool SodaRecognitionResult::has_endpoint_reason() const {
  return _internal_has_endpoint_reason();
}
inline void SodaRecognitionResult::clear_endpoint_reason() {
  _impl_.endpoint_reason_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::speech::soda::chrome::SodaRecognitionResult_FinalResultEndpointReason SodaRecognitionResult::_internal_endpoint_reason() const {
  return static_cast< ::speech::soda::chrome::SodaRecognitionResult_FinalResultEndpointReason >(_impl_.endpoint_reason_);
}
inline ::speech::soda::chrome::SodaRecognitionResult_FinalResultEndpointReason SodaRecognitionResult::endpoint_reason() const {
  // @@protoc_insertion_point(field_get:speech.soda.chrome.SodaRecognitionResult.endpoint_reason)
  return _internal_endpoint_reason();
}
inline void SodaRecognitionResult::_internal_set_endpoint_reason(::speech::soda::chrome::SodaRecognitionResult_FinalResultEndpointReason value) {
  assert(::speech::soda::chrome::SodaRecognitionResult_FinalResultEndpointReason_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.endpoint_reason_ = value;
}
inline void SodaRecognitionResult::set_endpoint_reason(::speech::soda::chrome::SodaRecognitionResult_FinalResultEndpointReason value) {
  _internal_set_endpoint_reason(value);
  // @@protoc_insertion_point(field_set:speech.soda.chrome.SodaRecognitionResult.endpoint_reason)
}

// optional .speech.soda.chrome.TimingMetrics timing_metrics = 4;
inline bool SodaRecognitionResult::_internal_has_timing_metrics() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.timing_metrics_ != nullptr);
  return value;
}
inline bool SodaRecognitionResult::has_timing_metrics() const {
  return _internal_has_timing_metrics();
}
inline void SodaRecognitionResult::clear_timing_metrics() {
  if (_impl_.timing_metrics_ != nullptr) _impl_.timing_metrics_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::speech::soda::chrome::TimingMetrics& SodaRecognitionResult::_internal_timing_metrics() const {
  const ::speech::soda::chrome::TimingMetrics* p = _impl_.timing_metrics_;
  return p != nullptr ? *p : reinterpret_cast<const ::speech::soda::chrome::TimingMetrics&>(
      ::speech::soda::chrome::_TimingMetrics_default_instance_);
}
inline const ::speech::soda::chrome::TimingMetrics& SodaRecognitionResult::timing_metrics() const {
  // @@protoc_insertion_point(field_get:speech.soda.chrome.SodaRecognitionResult.timing_metrics)
  return _internal_timing_metrics();
}
inline void SodaRecognitionResult::unsafe_arena_set_allocated_timing_metrics(
    ::speech::soda::chrome::TimingMetrics* timing_metrics) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.timing_metrics_);
  }
  _impl_.timing_metrics_ = timing_metrics;
  if (timing_metrics) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:speech.soda.chrome.SodaRecognitionResult.timing_metrics)
}
inline ::speech::soda::chrome::TimingMetrics* SodaRecognitionResult::release_timing_metrics() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::speech::soda::chrome::TimingMetrics* temp = _impl_.timing_metrics_;
  _impl_.timing_metrics_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::speech::soda::chrome::TimingMetrics* SodaRecognitionResult::unsafe_arena_release_timing_metrics() {
  // @@protoc_insertion_point(field_release:speech.soda.chrome.SodaRecognitionResult.timing_metrics)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::speech::soda::chrome::TimingMetrics* temp = _impl_.timing_metrics_;
  _impl_.timing_metrics_ = nullptr;
  return temp;
}
inline ::speech::soda::chrome::TimingMetrics* SodaRecognitionResult::_internal_mutable_timing_metrics() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.timing_metrics_ == nullptr) {
    auto* p = CreateMaybeMessage<::speech::soda::chrome::TimingMetrics>(GetArenaForAllocation());
    _impl_.timing_metrics_ = p;
  }
  return _impl_.timing_metrics_;
}
inline ::speech::soda::chrome::TimingMetrics* SodaRecognitionResult::mutable_timing_metrics() {
  ::speech::soda::chrome::TimingMetrics* _msg = _internal_mutable_timing_metrics();
  // @@protoc_insertion_point(field_mutable:speech.soda.chrome.SodaRecognitionResult.timing_metrics)
  return _msg;
}
inline void SodaRecognitionResult::set_allocated_timing_metrics(::speech::soda::chrome::TimingMetrics* timing_metrics) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.timing_metrics_;
  }
  if (timing_metrics) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(timing_metrics);
    if (message_arena != submessage_arena) {
      timing_metrics = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, timing_metrics, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.timing_metrics_ = timing_metrics;
  // @@protoc_insertion_point(field_set_allocated:speech.soda.chrome.SodaRecognitionResult.timing_metrics)
}

// repeated .speech.soda.chrome.HypothesisPart hypothesis_part = 5;
inline int SodaRecognitionResult::_internal_hypothesis_part_size() const {
  return _impl_.hypothesis_part_.size();
}
inline int SodaRecognitionResult::hypothesis_part_size() const {
  return _internal_hypothesis_part_size();
}
inline void SodaRecognitionResult::clear_hypothesis_part() {
  _impl_.hypothesis_part_.Clear();
}
inline ::speech::soda::chrome::HypothesisPart* SodaRecognitionResult::mutable_hypothesis_part(int index) {
  // @@protoc_insertion_point(field_mutable:speech.soda.chrome.SodaRecognitionResult.hypothesis_part)
  return _impl_.hypothesis_part_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::speech::soda::chrome::HypothesisPart >*
SodaRecognitionResult::mutable_hypothesis_part() {
  // @@protoc_insertion_point(field_mutable_list:speech.soda.chrome.SodaRecognitionResult.hypothesis_part)
  return &_impl_.hypothesis_part_;
}
inline const ::speech::soda::chrome::HypothesisPart& SodaRecognitionResult::_internal_hypothesis_part(int index) const {
  return _impl_.hypothesis_part_.Get(index);
}
inline const ::speech::soda::chrome::HypothesisPart& SodaRecognitionResult::hypothesis_part(int index) const {
  // @@protoc_insertion_point(field_get:speech.soda.chrome.SodaRecognitionResult.hypothesis_part)
  return _internal_hypothesis_part(index);
}
inline ::speech::soda::chrome::HypothesisPart* SodaRecognitionResult::_internal_add_hypothesis_part() {
  return _impl_.hypothesis_part_.Add();
}
inline ::speech::soda::chrome::HypothesisPart* SodaRecognitionResult::add_hypothesis_part() {
  ::speech::soda::chrome::HypothesisPart* _add = _internal_add_hypothesis_part();
  // @@protoc_insertion_point(field_add:speech.soda.chrome.SodaRecognitionResult.hypothesis_part)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::speech::soda::chrome::HypothesisPart >&
SodaRecognitionResult::hypothesis_part() const {
  // @@protoc_insertion_point(field_list:speech.soda.chrome.SodaRecognitionResult.hypothesis_part)
  return _impl_.hypothesis_part_;
}

// -------------------------------------------------------------------

// SodaEndpointEvent

// optional .speech.soda.chrome.SodaEndpointEvent.EndpointType endpoint_type = 1 [default = UNKNOWN];
inline bool SodaEndpointEvent::_internal_has_endpoint_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SodaEndpointEvent::has_endpoint_type() const {
  return _internal_has_endpoint_type();
}
inline void SodaEndpointEvent::clear_endpoint_type() {
  _impl_.endpoint_type_ = 4;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::speech::soda::chrome::SodaEndpointEvent_EndpointType SodaEndpointEvent::_internal_endpoint_type() const {
  return static_cast< ::speech::soda::chrome::SodaEndpointEvent_EndpointType >(_impl_.endpoint_type_);
}
inline ::speech::soda::chrome::SodaEndpointEvent_EndpointType SodaEndpointEvent::endpoint_type() const {
  // @@protoc_insertion_point(field_get:speech.soda.chrome.SodaEndpointEvent.endpoint_type)
  return _internal_endpoint_type();
}
inline void SodaEndpointEvent::_internal_set_endpoint_type(::speech::soda::chrome::SodaEndpointEvent_EndpointType value) {
  assert(::speech::soda::chrome::SodaEndpointEvent_EndpointType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.endpoint_type_ = value;
}
inline void SodaEndpointEvent::set_endpoint_type(::speech::soda::chrome::SodaEndpointEvent_EndpointType value) {
  _internal_set_endpoint_type(value);
  // @@protoc_insertion_point(field_set:speech.soda.chrome.SodaEndpointEvent.endpoint_type)
}

// optional .speech.soda.chrome.TimingMetrics timing_metrics = 2;
inline bool SodaEndpointEvent::_internal_has_timing_metrics() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.timing_metrics_ != nullptr);
  return value;
}
inline bool SodaEndpointEvent::has_timing_metrics() const {
  return _internal_has_timing_metrics();
}
inline void SodaEndpointEvent::clear_timing_metrics() {
  if (_impl_.timing_metrics_ != nullptr) _impl_.timing_metrics_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::speech::soda::chrome::TimingMetrics& SodaEndpointEvent::_internal_timing_metrics() const {
  const ::speech::soda::chrome::TimingMetrics* p = _impl_.timing_metrics_;
  return p != nullptr ? *p : reinterpret_cast<const ::speech::soda::chrome::TimingMetrics&>(
      ::speech::soda::chrome::_TimingMetrics_default_instance_);
}
inline const ::speech::soda::chrome::TimingMetrics& SodaEndpointEvent::timing_metrics() const {
  // @@protoc_insertion_point(field_get:speech.soda.chrome.SodaEndpointEvent.timing_metrics)
  return _internal_timing_metrics();
}
inline void SodaEndpointEvent::unsafe_arena_set_allocated_timing_metrics(
    ::speech::soda::chrome::TimingMetrics* timing_metrics) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.timing_metrics_);
  }
  _impl_.timing_metrics_ = timing_metrics;
  if (timing_metrics) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:speech.soda.chrome.SodaEndpointEvent.timing_metrics)
}
inline ::speech::soda::chrome::TimingMetrics* SodaEndpointEvent::release_timing_metrics() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::speech::soda::chrome::TimingMetrics* temp = _impl_.timing_metrics_;
  _impl_.timing_metrics_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::speech::soda::chrome::TimingMetrics* SodaEndpointEvent::unsafe_arena_release_timing_metrics() {
  // @@protoc_insertion_point(field_release:speech.soda.chrome.SodaEndpointEvent.timing_metrics)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::speech::soda::chrome::TimingMetrics* temp = _impl_.timing_metrics_;
  _impl_.timing_metrics_ = nullptr;
  return temp;
}
inline ::speech::soda::chrome::TimingMetrics* SodaEndpointEvent::_internal_mutable_timing_metrics() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.timing_metrics_ == nullptr) {
    auto* p = CreateMaybeMessage<::speech::soda::chrome::TimingMetrics>(GetArenaForAllocation());
    _impl_.timing_metrics_ = p;
  }
  return _impl_.timing_metrics_;
}
inline ::speech::soda::chrome::TimingMetrics* SodaEndpointEvent::mutable_timing_metrics() {
  ::speech::soda::chrome::TimingMetrics* _msg = _internal_mutable_timing_metrics();
  // @@protoc_insertion_point(field_mutable:speech.soda.chrome.SodaEndpointEvent.timing_metrics)
  return _msg;
}
inline void SodaEndpointEvent::set_allocated_timing_metrics(::speech::soda::chrome::TimingMetrics* timing_metrics) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.timing_metrics_;
  }
  if (timing_metrics) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(timing_metrics);
    if (message_arena != submessage_arena) {
      timing_metrics = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, timing_metrics, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.timing_metrics_ = timing_metrics;
  // @@protoc_insertion_point(field_set_allocated:speech.soda.chrome.SodaEndpointEvent.timing_metrics)
}

// -------------------------------------------------------------------

// SodaAudioLevelInfo

// optional float rms = 1;
inline bool SodaAudioLevelInfo::_internal_has_rms() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SodaAudioLevelInfo::has_rms() const {
  return _internal_has_rms();
}
inline void SodaAudioLevelInfo::clear_rms() {
  _impl_.rms_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline float SodaAudioLevelInfo::_internal_rms() const {
  return _impl_.rms_;
}
inline float SodaAudioLevelInfo::rms() const {
  // @@protoc_insertion_point(field_get:speech.soda.chrome.SodaAudioLevelInfo.rms)
  return _internal_rms();
}
inline void SodaAudioLevelInfo::_internal_set_rms(float value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.rms_ = value;
}
inline void SodaAudioLevelInfo::set_rms(float value) {
  _internal_set_rms(value);
  // @@protoc_insertion_point(field_set:speech.soda.chrome.SodaAudioLevelInfo.rms)
}

// optional float audio_level = 2;
inline bool SodaAudioLevelInfo::_internal_has_audio_level() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SodaAudioLevelInfo::has_audio_level() const {
  return _internal_has_audio_level();
}
inline void SodaAudioLevelInfo::clear_audio_level() {
  _impl_.audio_level_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline float SodaAudioLevelInfo::_internal_audio_level() const {
  return _impl_.audio_level_;
}
inline float SodaAudioLevelInfo::audio_level() const {
  // @@protoc_insertion_point(field_get:speech.soda.chrome.SodaAudioLevelInfo.audio_level)
  return _internal_audio_level();
}
inline void SodaAudioLevelInfo::_internal_set_audio_level(float value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.audio_level_ = value;
}
inline void SodaAudioLevelInfo::set_audio_level(float value) {
  _internal_set_audio_level(value);
  // @@protoc_insertion_point(field_set:speech.soda.chrome.SodaAudioLevelInfo.audio_level)
}

// optional int64 audio_time_usec = 3;
inline bool SodaAudioLevelInfo::_internal_has_audio_time_usec() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool SodaAudioLevelInfo::has_audio_time_usec() const {
  return _internal_has_audio_time_usec();
}
inline void SodaAudioLevelInfo::clear_audio_time_usec() {
  _impl_.audio_time_usec_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int64_t SodaAudioLevelInfo::_internal_audio_time_usec() const {
  return _impl_.audio_time_usec_;
}
inline int64_t SodaAudioLevelInfo::audio_time_usec() const {
  // @@protoc_insertion_point(field_get:speech.soda.chrome.SodaAudioLevelInfo.audio_time_usec)
  return _internal_audio_time_usec();
}
inline void SodaAudioLevelInfo::_internal_set_audio_time_usec(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.audio_time_usec_ = value;
}
inline void SodaAudioLevelInfo::set_audio_time_usec(int64_t value) {
  _internal_set_audio_time_usec(value);
  // @@protoc_insertion_point(field_set:speech.soda.chrome.SodaAudioLevelInfo.audio_time_usec)
}

// -------------------------------------------------------------------

// SodaLangIdEvent

// optional string language = 1;
inline bool SodaLangIdEvent::_internal_has_language() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SodaLangIdEvent::has_language() const {
  return _internal_has_language();
}
inline void SodaLangIdEvent::clear_language() {
  _impl_.language_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SodaLangIdEvent::language() const {
  // @@protoc_insertion_point(field_get:speech.soda.chrome.SodaLangIdEvent.language)
  return _internal_language();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SodaLangIdEvent::set_language(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.language_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:speech.soda.chrome.SodaLangIdEvent.language)
}
inline std::string* SodaLangIdEvent::mutable_language() {
  std::string* _s = _internal_mutable_language();
  // @@protoc_insertion_point(field_mutable:speech.soda.chrome.SodaLangIdEvent.language)
  return _s;
}
inline const std::string& SodaLangIdEvent::_internal_language() const {
  return _impl_.language_.Get();
}
inline void SodaLangIdEvent::_internal_set_language(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.language_.Set(value, GetArenaForAllocation());
}
inline std::string* SodaLangIdEvent::_internal_mutable_language() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.language_.Mutable(GetArenaForAllocation());
}
inline std::string* SodaLangIdEvent::release_language() {
  // @@protoc_insertion_point(field_release:speech.soda.chrome.SodaLangIdEvent.language)
  if (!_internal_has_language()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.language_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.language_.IsDefault()) {
    _impl_.language_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SodaLangIdEvent::set_allocated_language(std::string* language) {
  if (language != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.language_.SetAllocated(language, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.language_.IsDefault()) {
    _impl_.language_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:speech.soda.chrome.SodaLangIdEvent.language)
}

// optional int32 confidence_level = 2;
inline bool SodaLangIdEvent::_internal_has_confidence_level() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SodaLangIdEvent::has_confidence_level() const {
  return _internal_has_confidence_level();
}
inline void SodaLangIdEvent::clear_confidence_level() {
  _impl_.confidence_level_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t SodaLangIdEvent::_internal_confidence_level() const {
  return _impl_.confidence_level_;
}
inline int32_t SodaLangIdEvent::confidence_level() const {
  // @@protoc_insertion_point(field_get:speech.soda.chrome.SodaLangIdEvent.confidence_level)
  return _internal_confidence_level();
}
inline void SodaLangIdEvent::_internal_set_confidence_level(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.confidence_level_ = value;
}
inline void SodaLangIdEvent::set_confidence_level(int32_t value) {
  _internal_set_confidence_level(value);
  // @@protoc_insertion_point(field_set:speech.soda.chrome.SodaLangIdEvent.confidence_level)
}

// -------------------------------------------------------------------

// SodaResponse

// optional .speech.soda.chrome.SodaResponse.SodaMessageType soda_type = 1 [default = UNKNOWN];
inline bool SodaResponse::_internal_has_soda_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool SodaResponse::has_soda_type() const {
  return _internal_has_soda_type();
}
inline void SodaResponse::clear_soda_type() {
  _impl_.soda_type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::speech::soda::chrome::SodaResponse_SodaMessageType SodaResponse::_internal_soda_type() const {
  return static_cast< ::speech::soda::chrome::SodaResponse_SodaMessageType >(_impl_.soda_type_);
}
inline ::speech::soda::chrome::SodaResponse_SodaMessageType SodaResponse::soda_type() const {
  // @@protoc_insertion_point(field_get:speech.soda.chrome.SodaResponse.soda_type)
  return _internal_soda_type();
}
inline void SodaResponse::_internal_set_soda_type(::speech::soda::chrome::SodaResponse_SodaMessageType value) {
  assert(::speech::soda::chrome::SodaResponse_SodaMessageType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.soda_type_ = value;
}
inline void SodaResponse::set_soda_type(::speech::soda::chrome::SodaResponse_SodaMessageType value) {
  _internal_set_soda_type(value);
  // @@protoc_insertion_point(field_set:speech.soda.chrome.SodaResponse.soda_type)
}

// optional .speech.soda.chrome.SodaRecognitionResult recognition_result = 2;
inline bool SodaResponse::_internal_has_recognition_result() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.recognition_result_ != nullptr);
  return value;
}
inline bool SodaResponse::has_recognition_result() const {
  return _internal_has_recognition_result();
}
inline void SodaResponse::clear_recognition_result() {
  if (_impl_.recognition_result_ != nullptr) _impl_.recognition_result_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::speech::soda::chrome::SodaRecognitionResult& SodaResponse::_internal_recognition_result() const {
  const ::speech::soda::chrome::SodaRecognitionResult* p = _impl_.recognition_result_;
  return p != nullptr ? *p : reinterpret_cast<const ::speech::soda::chrome::SodaRecognitionResult&>(
      ::speech::soda::chrome::_SodaRecognitionResult_default_instance_);
}
inline const ::speech::soda::chrome::SodaRecognitionResult& SodaResponse::recognition_result() const {
  // @@protoc_insertion_point(field_get:speech.soda.chrome.SodaResponse.recognition_result)
  return _internal_recognition_result();
}
inline void SodaResponse::unsafe_arena_set_allocated_recognition_result(
    ::speech::soda::chrome::SodaRecognitionResult* recognition_result) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.recognition_result_);
  }
  _impl_.recognition_result_ = recognition_result;
  if (recognition_result) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:speech.soda.chrome.SodaResponse.recognition_result)
}
inline ::speech::soda::chrome::SodaRecognitionResult* SodaResponse::release_recognition_result() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::speech::soda::chrome::SodaRecognitionResult* temp = _impl_.recognition_result_;
  _impl_.recognition_result_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::speech::soda::chrome::SodaRecognitionResult* SodaResponse::unsafe_arena_release_recognition_result() {
  // @@protoc_insertion_point(field_release:speech.soda.chrome.SodaResponse.recognition_result)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::speech::soda::chrome::SodaRecognitionResult* temp = _impl_.recognition_result_;
  _impl_.recognition_result_ = nullptr;
  return temp;
}
inline ::speech::soda::chrome::SodaRecognitionResult* SodaResponse::_internal_mutable_recognition_result() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.recognition_result_ == nullptr) {
    auto* p = CreateMaybeMessage<::speech::soda::chrome::SodaRecognitionResult>(GetArenaForAllocation());
    _impl_.recognition_result_ = p;
  }
  return _impl_.recognition_result_;
}
inline ::speech::soda::chrome::SodaRecognitionResult* SodaResponse::mutable_recognition_result() {
  ::speech::soda::chrome::SodaRecognitionResult* _msg = _internal_mutable_recognition_result();
  // @@protoc_insertion_point(field_mutable:speech.soda.chrome.SodaResponse.recognition_result)
  return _msg;
}
inline void SodaResponse::set_allocated_recognition_result(::speech::soda::chrome::SodaRecognitionResult* recognition_result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.recognition_result_;
  }
  if (recognition_result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(recognition_result);
    if (message_arena != submessage_arena) {
      recognition_result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, recognition_result, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.recognition_result_ = recognition_result;
  // @@protoc_insertion_point(field_set_allocated:speech.soda.chrome.SodaResponse.recognition_result)
}

// optional .speech.soda.chrome.SodaEndpointEvent endpoint_event = 3;
inline bool SodaResponse::_internal_has_endpoint_event() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.endpoint_event_ != nullptr);
  return value;
}
inline bool SodaResponse::has_endpoint_event() const {
  return _internal_has_endpoint_event();
}
inline void SodaResponse::clear_endpoint_event() {
  if (_impl_.endpoint_event_ != nullptr) _impl_.endpoint_event_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::speech::soda::chrome::SodaEndpointEvent& SodaResponse::_internal_endpoint_event() const {
  const ::speech::soda::chrome::SodaEndpointEvent* p = _impl_.endpoint_event_;
  return p != nullptr ? *p : reinterpret_cast<const ::speech::soda::chrome::SodaEndpointEvent&>(
      ::speech::soda::chrome::_SodaEndpointEvent_default_instance_);
}
inline const ::speech::soda::chrome::SodaEndpointEvent& SodaResponse::endpoint_event() const {
  // @@protoc_insertion_point(field_get:speech.soda.chrome.SodaResponse.endpoint_event)
  return _internal_endpoint_event();
}
inline void SodaResponse::unsafe_arena_set_allocated_endpoint_event(
    ::speech::soda::chrome::SodaEndpointEvent* endpoint_event) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.endpoint_event_);
  }
  _impl_.endpoint_event_ = endpoint_event;
  if (endpoint_event) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:speech.soda.chrome.SodaResponse.endpoint_event)
}
inline ::speech::soda::chrome::SodaEndpointEvent* SodaResponse::release_endpoint_event() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::speech::soda::chrome::SodaEndpointEvent* temp = _impl_.endpoint_event_;
  _impl_.endpoint_event_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::speech::soda::chrome::SodaEndpointEvent* SodaResponse::unsafe_arena_release_endpoint_event() {
  // @@protoc_insertion_point(field_release:speech.soda.chrome.SodaResponse.endpoint_event)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::speech::soda::chrome::SodaEndpointEvent* temp = _impl_.endpoint_event_;
  _impl_.endpoint_event_ = nullptr;
  return temp;
}
inline ::speech::soda::chrome::SodaEndpointEvent* SodaResponse::_internal_mutable_endpoint_event() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.endpoint_event_ == nullptr) {
    auto* p = CreateMaybeMessage<::speech::soda::chrome::SodaEndpointEvent>(GetArenaForAllocation());
    _impl_.endpoint_event_ = p;
  }
  return _impl_.endpoint_event_;
}
inline ::speech::soda::chrome::SodaEndpointEvent* SodaResponse::mutable_endpoint_event() {
  ::speech::soda::chrome::SodaEndpointEvent* _msg = _internal_mutable_endpoint_event();
  // @@protoc_insertion_point(field_mutable:speech.soda.chrome.SodaResponse.endpoint_event)
  return _msg;
}
inline void SodaResponse::set_allocated_endpoint_event(::speech::soda::chrome::SodaEndpointEvent* endpoint_event) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.endpoint_event_;
  }
  if (endpoint_event) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(endpoint_event);
    if (message_arena != submessage_arena) {
      endpoint_event = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, endpoint_event, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.endpoint_event_ = endpoint_event;
  // @@protoc_insertion_point(field_set_allocated:speech.soda.chrome.SodaResponse.endpoint_event)
}

// optional .speech.soda.chrome.SodaAudioLevelInfo audio_level_info = 4;
inline bool SodaResponse::_internal_has_audio_level_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.audio_level_info_ != nullptr);
  return value;
}
inline bool SodaResponse::has_audio_level_info() const {
  return _internal_has_audio_level_info();
}
inline void SodaResponse::clear_audio_level_info() {
  if (_impl_.audio_level_info_ != nullptr) _impl_.audio_level_info_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::speech::soda::chrome::SodaAudioLevelInfo& SodaResponse::_internal_audio_level_info() const {
  const ::speech::soda::chrome::SodaAudioLevelInfo* p = _impl_.audio_level_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::speech::soda::chrome::SodaAudioLevelInfo&>(
      ::speech::soda::chrome::_SodaAudioLevelInfo_default_instance_);
}
inline const ::speech::soda::chrome::SodaAudioLevelInfo& SodaResponse::audio_level_info() const {
  // @@protoc_insertion_point(field_get:speech.soda.chrome.SodaResponse.audio_level_info)
  return _internal_audio_level_info();
}
inline void SodaResponse::unsafe_arena_set_allocated_audio_level_info(
    ::speech::soda::chrome::SodaAudioLevelInfo* audio_level_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.audio_level_info_);
  }
  _impl_.audio_level_info_ = audio_level_info;
  if (audio_level_info) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:speech.soda.chrome.SodaResponse.audio_level_info)
}
inline ::speech::soda::chrome::SodaAudioLevelInfo* SodaResponse::release_audio_level_info() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::speech::soda::chrome::SodaAudioLevelInfo* temp = _impl_.audio_level_info_;
  _impl_.audio_level_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::speech::soda::chrome::SodaAudioLevelInfo* SodaResponse::unsafe_arena_release_audio_level_info() {
  // @@protoc_insertion_point(field_release:speech.soda.chrome.SodaResponse.audio_level_info)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::speech::soda::chrome::SodaAudioLevelInfo* temp = _impl_.audio_level_info_;
  _impl_.audio_level_info_ = nullptr;
  return temp;
}
inline ::speech::soda::chrome::SodaAudioLevelInfo* SodaResponse::_internal_mutable_audio_level_info() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.audio_level_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::speech::soda::chrome::SodaAudioLevelInfo>(GetArenaForAllocation());
    _impl_.audio_level_info_ = p;
  }
  return _impl_.audio_level_info_;
}
inline ::speech::soda::chrome::SodaAudioLevelInfo* SodaResponse::mutable_audio_level_info() {
  ::speech::soda::chrome::SodaAudioLevelInfo* _msg = _internal_mutable_audio_level_info();
  // @@protoc_insertion_point(field_mutable:speech.soda.chrome.SodaResponse.audio_level_info)
  return _msg;
}
inline void SodaResponse::set_allocated_audio_level_info(::speech::soda::chrome::SodaAudioLevelInfo* audio_level_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.audio_level_info_;
  }
  if (audio_level_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(audio_level_info);
    if (message_arena != submessage_arena) {
      audio_level_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, audio_level_info, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.audio_level_info_ = audio_level_info;
  // @@protoc_insertion_point(field_set_allocated:speech.soda.chrome.SodaResponse.audio_level_info)
}

// optional .speech.soda.chrome.SodaLangIdEvent langid_event = 5;
inline bool SodaResponse::_internal_has_langid_event() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.langid_event_ != nullptr);
  return value;
}
inline bool SodaResponse::has_langid_event() const {
  return _internal_has_langid_event();
}
inline void SodaResponse::clear_langid_event() {
  if (_impl_.langid_event_ != nullptr) _impl_.langid_event_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::speech::soda::chrome::SodaLangIdEvent& SodaResponse::_internal_langid_event() const {
  const ::speech::soda::chrome::SodaLangIdEvent* p = _impl_.langid_event_;
  return p != nullptr ? *p : reinterpret_cast<const ::speech::soda::chrome::SodaLangIdEvent&>(
      ::speech::soda::chrome::_SodaLangIdEvent_default_instance_);
}
inline const ::speech::soda::chrome::SodaLangIdEvent& SodaResponse::langid_event() const {
  // @@protoc_insertion_point(field_get:speech.soda.chrome.SodaResponse.langid_event)
  return _internal_langid_event();
}
inline void SodaResponse::unsafe_arena_set_allocated_langid_event(
    ::speech::soda::chrome::SodaLangIdEvent* langid_event) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.langid_event_);
  }
  _impl_.langid_event_ = langid_event;
  if (langid_event) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:speech.soda.chrome.SodaResponse.langid_event)
}
inline ::speech::soda::chrome::SodaLangIdEvent* SodaResponse::release_langid_event() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::speech::soda::chrome::SodaLangIdEvent* temp = _impl_.langid_event_;
  _impl_.langid_event_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::speech::soda::chrome::SodaLangIdEvent* SodaResponse::unsafe_arena_release_langid_event() {
  // @@protoc_insertion_point(field_release:speech.soda.chrome.SodaResponse.langid_event)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::speech::soda::chrome::SodaLangIdEvent* temp = _impl_.langid_event_;
  _impl_.langid_event_ = nullptr;
  return temp;
}
inline ::speech::soda::chrome::SodaLangIdEvent* SodaResponse::_internal_mutable_langid_event() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.langid_event_ == nullptr) {
    auto* p = CreateMaybeMessage<::speech::soda::chrome::SodaLangIdEvent>(GetArenaForAllocation());
    _impl_.langid_event_ = p;
  }
  return _impl_.langid_event_;
}
inline ::speech::soda::chrome::SodaLangIdEvent* SodaResponse::mutable_langid_event() {
  ::speech::soda::chrome::SodaLangIdEvent* _msg = _internal_mutable_langid_event();
  // @@protoc_insertion_point(field_mutable:speech.soda.chrome.SodaResponse.langid_event)
  return _msg;
}
inline void SodaResponse::set_allocated_langid_event(::speech::soda::chrome::SodaLangIdEvent* langid_event) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.langid_event_;
  }
  if (langid_event) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(langid_event);
    if (message_arena != submessage_arena) {
      langid_event = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, langid_event, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.langid_event_ = langid_event;
  // @@protoc_insertion_point(field_set_allocated:speech.soda.chrome.SodaResponse.langid_event)
}

// repeated string log_lines = 6;
inline int SodaResponse::_internal_log_lines_size() const {
  return _impl_.log_lines_.size();
}
inline int SodaResponse::log_lines_size() const {
  return _internal_log_lines_size();
}
inline void SodaResponse::clear_log_lines() {
  _impl_.log_lines_.Clear();
}
inline std::string* SodaResponse::add_log_lines() {
  std::string* _s = _internal_add_log_lines();
  // @@protoc_insertion_point(field_add_mutable:speech.soda.chrome.SodaResponse.log_lines)
  return _s;
}
inline const std::string& SodaResponse::_internal_log_lines(int index) const {
  return _impl_.log_lines_.Get(index);
}
inline const std::string& SodaResponse::log_lines(int index) const {
  // @@protoc_insertion_point(field_get:speech.soda.chrome.SodaResponse.log_lines)
  return _internal_log_lines(index);
}
inline std::string* SodaResponse::mutable_log_lines(int index) {
  // @@protoc_insertion_point(field_mutable:speech.soda.chrome.SodaResponse.log_lines)
  return _impl_.log_lines_.Mutable(index);
}
inline void SodaResponse::set_log_lines(int index, const std::string& value) {
  _impl_.log_lines_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:speech.soda.chrome.SodaResponse.log_lines)
}
inline void SodaResponse::set_log_lines(int index, std::string&& value) {
  _impl_.log_lines_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:speech.soda.chrome.SodaResponse.log_lines)
}
inline void SodaResponse::set_log_lines(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.log_lines_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:speech.soda.chrome.SodaResponse.log_lines)
}
inline void SodaResponse::set_log_lines(int index, const char* value, size_t size) {
  _impl_.log_lines_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:speech.soda.chrome.SodaResponse.log_lines)
}
inline std::string* SodaResponse::_internal_add_log_lines() {
  return _impl_.log_lines_.Add();
}
inline void SodaResponse::add_log_lines(const std::string& value) {
  _impl_.log_lines_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:speech.soda.chrome.SodaResponse.log_lines)
}
inline void SodaResponse::add_log_lines(std::string&& value) {
  _impl_.log_lines_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:speech.soda.chrome.SodaResponse.log_lines)
}
inline void SodaResponse::add_log_lines(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.log_lines_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:speech.soda.chrome.SodaResponse.log_lines)
}
inline void SodaResponse::add_log_lines(const char* value, size_t size) {
  _impl_.log_lines_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:speech.soda.chrome.SodaResponse.log_lines)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
SodaResponse::log_lines() const {
  // @@protoc_insertion_point(field_list:speech.soda.chrome.SodaResponse.log_lines)
  return _impl_.log_lines_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
SodaResponse::mutable_log_lines() {
  // @@protoc_insertion_point(field_mutable_list:speech.soda.chrome.SodaResponse.log_lines)
  return &_impl_.log_lines_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace chrome
}  // namespace soda
}  // namespace speech

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::speech::soda::chrome::ExtendedSodaConfigMsg_RecognitionMode> : ::std::true_type {};
template <> struct is_proto_enum< ::speech::soda::chrome::SodaRecognitionResult_ResultType> : ::std::true_type {};
template <> struct is_proto_enum< ::speech::soda::chrome::SodaRecognitionResult_FinalResultEndpointReason> : ::std::true_type {};
template <> struct is_proto_enum< ::speech::soda::chrome::SodaEndpointEvent_EndpointType> : ::std::true_type {};
template <> struct is_proto_enum< ::speech::soda::chrome::SodaResponse_SodaMessageType> : ::std::true_type {};

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_soda_5fapi_2eproto
